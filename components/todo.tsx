/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/cthBC3Tlnxc
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client"

import { useEffect, useState, useRef } from "react";
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@/components/ui/collapsible"
import Highlight, { type HighlightContext, type FocusedWindow } from "@highlight-ai/app-runtime";
import { useName } from './providers/NameProvider'; // Adjust the path based on where you save the context

export interface Task {
  id: string;
  text: string;
  completed: boolean;
  fadingOut: boolean;
}

interface TodoItemProps {
  todo: Task;
  onCheckedChange: (id: string) => void;
  onDelete: (id: string) => void;
}

const TodoItem: React.FC<TodoItemProps> = ({ todo, onCheckedChange, onDelete }) => {
  return (
    <div
      className={`flex items-center justify-between bg-muted rounded-md px-3 py-2 ${
        (todo.completed || todo.fadingOut) ? "line-through text-muted-foreground" : "text-card-foreground"
      } ${todo.fadingOut ? "fade-out" : ""}`}
    >
      <div className="flex items-center">
        <Checkbox
          id={`todo-${todo.id}`}
          checked={todo.completed}
          className="mr-2"
          onCheckedChange={() => onCheckedChange(todo.id)}
        />
        <label htmlFor={`todo-${todo.id}`}>{todo.text}</label>
      </div>
      <Button
        variant="ghost"
        size="icon"
        onClick={() => onDelete(todo.id)}
        className="text-muted-foreground hover:text-card-foreground"
      >
        <Trash2Icon className="w-4 h-4" />
      </Button>
    </div>
  );
}

export function Todo() {
  const lastCallTime = useRef(0);
  const [todos, setTodos] = useState<Task[]>([]);
  const [newTodo, setNewTodo] = useState("")
  const { name, handleNameUpdate } = useName(); // Destructure name and handleNameUpdate from the context
  const [ userName, setUserName] = useState(name);
  const nameRef = useRef(name); // Ref to hold the current name

  const [isEditingName, setIsEditingName] = useState(false)
  const [showCompletedTodos, setShowCompletedTodos] = useState(false)
  const completedTodos = todos.filter((todo) => todo.completed)
  const incompleteTodos = todos.filter((todo) => !todo.completed)

  useEffect(() => {
    nameRef.current = name;
  }, [name]);

  const handleUserNameEdit = () => {
    setIsEditingName(true)
  }
  const handleUserNameSave = (newName: string) => {
    handleNameUpdate(newName)
    setIsEditingName(false)
  }

  const tableName = "tasks";

  // Load tasks from the VectorDB
  const loadTasks = async () => {
    const tasks = await Highlight.vectorDB.getAllItems(tableName);
    // tasks is just a string array, convert it to Task[]
    const taskObjects = tasks.map((task, index: number) => {
      return { id: task.id, text: task.text, completed: task.metadata.completed || false, fadingOut: false };
    });
    setTodos(taskObjects);
  };

  const addTask = async (task: string) => {
    console.log("Adding task : ", task);
    await Highlight.vectorDB.insertItem(tableName, task, { completed: false });
    await Highlight.app.showNotification('New task added to TODO list', task);
    loadTasks();
  }

  useEffect(() => {
    const destructor = Highlight.app.addListener('onContext', async (context: HighlightContext) => {
      if (context.suggestion) {
        addTask(context.suggestion);
      }
    })

    return () => {
      destructor();
    };
  }, []);

  const detectTask = async (context: HighlightContext) => {
    const system_prompt = `You are a helpful AI assistant designed to analyze group conversations and detect whether any task has been assigned to the current user whose name will be provided.
    Your goal is to identify the following.
    1. Whether the current user has been assigned any task as a result of the group conversion?
    2. If the answer to the above question is yes, then a single line task that can be added to the TODO list of the user.

    Instructions:
    1. The user will provide a full name followed by a group conversation seen on their computer screen.
    2. Analyze the conversation and determine if there's a task the mentioned user needs to complete.
    3. Consider only explicitly mentioned tasks for the mentioned user.
    4. If a task is assigned, provide a short, single-line description that can be directly added to a todo list.
    5. The task should be something the user mentioned in the input needs to do, not tasks for other people.
    6. If no task is assigned, or if the conversation is promotional, advertisement-related, or addressed to someone else, output exactly "Task not assigned".
    7. Do not prioritize or categorize the task.
    8. Do not include any additional information such as due dates or associated people.
    9. If multiple tasks are present, choose the most relevant or important one.
    10. Provide only the task description without any additional context or explanation.

    Remember, your response should be either "Task assigned : " followed by a single-line task description or "Task not assigned" if no relevant task is assigned for the name of the user mentioned!.
    `;
    const user_prompt = "Name of the User : " + nameRef.current +  ".\nConversation : " + context.environment.ocrScreenContents;
    const grammar = `
      root ::= ("Task not assigned" | "Task assigned : " single-line)
      single-line ::= [^\n.]+ ("." | "\n")
      `;

    console.log("User Prompt", user_prompt);
    const response = await Highlight.inference.requestCompletionSlm(system_prompt, user_prompt, "")
    return response;
  }

  const isDuplicateTask = async (task: string) => {
    const closestTask = await Highlight.vectorDB.search(tableName, task, 1);
    if (closestTask.length === 0) {
      console.log("No closest task found");
      return false;
    }
    console.log("Closest task", closestTask);
    if (Math.abs(closestTask[0].distance) < 0.25) {
      console.log("Duplicate task detected");
      return true
    }
    console.log("New task detected");
    return false;
  }

  useEffect(() => {
    const onPeriodicForegroundAppCheck = async (context: FocusedWindow) => {
      console.log(context);
      // Check if it is slack
      if (context.url?.includes("app.slack.com") || context.appName === "Slack") {
        const now = Date.now();
        if (now - lastCallTime.current >= 30000) { // 30 seconds
          lastCallTime.current = now;
          console.log("Slack is open");
          const context = await Highlight.user.getContext(true)
          const task = await detectTask(context);
          console.log(task);
          if (task.startsWith("Task assigned : ")) {
            // Extract the task
            const taskText = task.replace("Task assigned : ", "");

            if (await isDuplicateTask(taskText)) {
              return;
            }
            await addTask(taskText);
          }

        } else {
          // console.log("Throttled: Context fetch not allowed yet");
        }
      }
    };

    //let removeListener = Highlight.app.addListener("onContext", onContext);
    let removeListener = Highlight.app.addListener("onPeriodicForegroundAppCheck", onPeriodicForegroundAppCheck);

    return () => {
      removeListener();
    };
  }, []);

  useEffect(() => {
    loadTasks();
  }, []);

  const addTodo = async () => {
    if (newTodo.trim() === "") {
      return;
    }
    if (await isDuplicateTask(newTodo)) {
      return;
    }
    await Highlight.vectorDB.insertItem(tableName, newTodo, { completed: false });
    setNewTodo("");
    loadTasks();
  }

  const toggleTodo = async (id: string) => {
    await Highlight.vectorDB.updateMetadata(tableName, id, { completed: !todos.find(todo => todo.id === id)?.completed });
    loadTasks();
  }

  const toggleTodoWithFadeOut = async (id: string) => {
    // Find the todo item and update its 'fadingOut' state temporarily
    const updatedTodos = todos.map(todo => {
      if (todo.id === id) {
        return { ...todo, fadingOut: true }; // Add a fadingOut property
      }
      return todo;
    });
    setTodos(updatedTodos);
    setTimeout(async () => {
      toggleTodo(id);
    }, 1000); // Delay of 1 second for the fade-out effect
  };

  const deleteTodo = async (id: string) => {
    await Highlight.vectorDB.deleteItem(tableName, id);
    loadTasks();
  };


  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <div className="w-full max-w-4xl p-6 bg-card rounded-lg shadow-md relative">
        <div className="absolute top-4 right-4 flex items-center space-x-2">
          <UserIcon className="w-5 h-5" />
          {isEditingName ? (
            <div className="flex items-center">
              <Input
                type="text"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                className="bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              />
              <Button
                onClick={() => handleUserNameSave(userName)}
                className="bg-primary text-primary-foreground rounded-md px-3 py-2 ml-2"
              >
                Save
              </Button>
            </div>
          ) : (
            <div className="cursor-pointer hover:underline" onClick={handleUserNameEdit}>
              {name}
            </div>
          )}
        </div>
        <h1 className="text-2xl font-bold mb-4 text-card-foreground">Todo List - alpha version</h1>
        <div className="flex items-center mb-4">
          <Input
            type="text"
            placeholder="Add a new todo"
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                addTodo()
              }
            }}
            className="flex-1 mr-2 bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
          />
          <Button onClick={addTodo} className="bg-primary text-primary-foreground rounded-md px-3 py-2">
            Add
          </Button>
        </div>
        <div className="space-y-2">
          {incompleteTodos.map((todo) => (
            <TodoItem
              key={todo.id}
              todo={todo}
              onCheckedChange={toggleTodoWithFadeOut}
              onDelete={deleteTodo}
            />
          ))}
        </div>
        <Collapsible
          open={showCompletedTodos}
          onOpenChange={() => setShowCompletedTodos(!showCompletedTodos)}
          className="mt-4"
        >
          <div className="flex justify-end">
            <CollapsibleTrigger className="flex items-center bg-muted rounded-md px-3 py-2 cursor-pointer justify-between">
              <div className="flex items-center">
                {showCompletedTodos ? (
                    <>
                      <ChevronDownIcon className="w-4 h-4 mr-2" />
                      Hide Completed Items
                    </>
                  ) : (
                    <>
                      <ChevronRightIcon className="w-4 h-4 mr-2" />
                      Show Completed Items
                    </>
                  )}
              </div>
            </CollapsibleTrigger>
          </div>
          <CollapsibleContent className="space-y-2 mt-2">
            {completedTodos.map((todo) => (
              <TodoItem
                key={todo.id}
                todo={todo}
                onCheckedChange={toggleTodo}
                onDelete={deleteTodo}
              />
            ))}
          </CollapsibleContent>
        </Collapsible>
      </div>
    </div>
  )
}

function ChevronRightIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m9 18 6-6-6-6" />
    </svg>
  )
}

function ChevronDownIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m6 9 6 6 6-6" />
    </svg>
  )
}

function Trash2Icon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 6h18" />
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
      <line x1="10" x2="10" y1="11" y2="17" />
      <line x1="14" x2="14" y1="11" y2="17" />
    </svg>
  )
}

function UserIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
      <circle cx="12" cy="7" r="4" />
    </svg>
  )
}