/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/cthBC3Tlnxc
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client"

import { useEffect, useState, useRef } from "react";
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@/components/ui/collapsible"
import Highlight, { type HighlightContext, type FocusedWindow } from "@highlight-ai/app-runtime";
import { useName } from './providers/NameProvider'; // Adjust the path based on where you save the context
import { v4 as uuidv4 } from 'uuid';
import { llm_system_prompt, slm_system_prompt } from './prompts';

type StatusType = 'pending' | 'completed' | 'deleted' | 'false_positive';
type AdditionMethodType = 'manually' | 'automatically' | 'semi_automatically';

export interface Task {
  id: string;
  text: string;
  status: StatusType;
  additionMethod: AdditionMethodType;
  fadingOut: boolean;
  lastModified: string;  // ISO 8601 format
}

interface TodoItemProps {
  todo: Task;
  onCheckedChange: (id: string) => void;
  onDelete: (id: string) => void;
  onUpdate: (id: string, text: string) => void;
}

const TodoItem: React.FC<TodoItemProps> = ({ todo, onCheckedChange, onDelete, onUpdate }) => {
  // State to toggle edit mode
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);

  // Handle double click to toggle edit mode
  const handleClick = () => {
    setIsEditing(true);
  };

  useEffect(() => {
    setEditText(todo.text);
  }, [todo.text]);

  // Handle input change
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEditText(e.target.value);
  };

  // Handle submission of the new text
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      if (e.key === 'Enter') {
        onUpdate(todo.id, editText);  // Call onUpdate with the new text
      }
      setIsEditing(false);
      setEditText(todo.text);  // Reset the input field on escape
    }
  };

  // Handle blur to exit edit mode
  const handleBlur = () => {
    onUpdate(todo.id, editText);
    setIsEditing(false);
  };

  return (
    <div
      className={`flex items-center justify-between bg-muted rounded-md px-3 py-2 ${
        (todo.status === 'completed' || todo.fadingOut) ? "line-through text-muted-foreground" : "text-card-foreground"
      } ${todo.fadingOut ? "fade-out" : ""}`}
    >
      <div className="flex items-center flex-grow">
        <Checkbox
          id={`todo-${todo.id}`}
          checked={todo.status === 'completed'}
          className="mr-2"
          onCheckedChange={() => onCheckedChange(todo.id)}
        />
        {isEditing ? (
          <input
            type="text"
            value={editText}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            onBlur={handleBlur}
            autoFocus
            className="flex-grow mr-2 px-2 py-1 rounded-md"
          />
        ) : (
          <label htmlFor={`todo-${todo.id}`} onClick={handleClick}>
            {todo.text}
          </label>
        )}
      </div>
      <Button
        variant="ghost"
        size="icon"
        onClick={() => onDelete(todo.id)}
        className="text-muted-foreground hover:text-card-foreground"
      >
        <Trash2Icon className="w-4 h-4" />
      </Button>
    </div>
  );
}

export function Todo() {
  const lastCallTime = useRef(0);
  const [todos, setTodos] = useState<Task[]>([]);
  const [newTodo, setNewTodo] = useState("")
  const { name, handleNameUpdate } = useName(); // Destructure name and handleNameUpdate from the context
  const [ userName, setUserName] = useState(name);
  const nameRef = useRef(name); // Ref to hold the current name

  const [isEditingName, setIsEditingName] = useState(false)
  const [showCompletedTodos, setShowCompletedTodos] = useState(false)
  const [showHelpSection, setShowHelpSection] = useState(false)
  const [hotKey, setHotKey] = useState("")
  const completedTodos = todos.filter((todo) => todo.status === 'completed')
  const incompleteTodos = todos.filter((todo) => todo.status === 'pending')
  const [slmCapable, setSlmCapable] = useState(false);

  const tasksTableName = "tasks";
  const sourcesTableName = "sources";

  useEffect(() => {
    nameRef.current = name;
  }, [name]);

  useEffect(() => {
    Highlight.permissions.requestBackgroundPermission();
  }, []);

  useEffect(() => {
    const getShowHelpSection = async () => {
      const showHelp = await Highlight.appStorage.get("showHelpSection") ?? true;
      setShowHelpSection(showHelp);
    }
    getShowHelpSection();
  }, []);

  useEffect(() => {
    const isSlmCapable = async () => {
      setSlmCapable(await Highlight.inference.isSlmCapable());
    }
    isSlmCapable();
  }, []);

  useEffect(() => {
    const getHotKey = async () => {
      const hotKey = await Highlight.app.getHotkey();
      setHotKey(hotKey);
    }
    getHotKey();
  }, []);

  const handleUserNameEdit = () => {
    setIsEditingName(true)
  }
  const handleUserNameSave = (newName: string) => {
    handleNameUpdate(newName)
    setIsEditingName(false)
  }

  // Load tasks from the VectorDB
  const loadTasks = async () => {
    await Highlight.vectorDB.createTable(tasksTableName); // Ensure table exists
    await Highlight.vectorDB.createTable(sourcesTableName); // Ensure table exists
    const tasks = await Highlight.vectorDB.getAllItems(tasksTableName);
    const taskObjects = tasks.map((task) => ({
      id: task.id,
      text: task.text,
      status: task.metadata.status,
      additionMethod: task.metadata.additionMethod,
      lastModified: task.metadata.lastModified,
      fadingOut: false
    }));
    setTodos(taskObjects);
  };

  const isDuplicateTask = async (similarTasks: any[], userPrompt: string | undefined): Promise<boolean> => {
    if (similarTasks.length > 0 && Math.abs(similarTasks[0].distance) < 0.35) {
      console.log("Similar Task Found");
      const existingTask = similarTasks[0];
      const metadata = JSON.parse(existingTask.metadata);
      const existingSourceId = metadata.sourceId;

      if (existingSourceId && userPrompt) {
        const existingSources = await Highlight.vectorDB.getAllItems(sourcesTableName);
        
        const existingSource = existingSources.find(source => source.metadata.sourceId === existingSourceId);
        
        const existingSourceVector = existingSource?.vector;
        
        let newSourceEmbedding;
        try {
          newSourceEmbedding = await Highlight.inference.getEmbedding(userPrompt);
        } catch (error) {
          console.error("Error getting new source embedding: ", error);
        }

        console.log("Existing Source Vector: ", existingSourceVector);
        console.log("New Source Embedding: ", newSourceEmbedding);
        
        const similarity = cosineSimilarity(existingSourceVector, newSourceEmbedding);
        console.log("Similarity : ", similarity);
        if (similarity > 0.9) {
          return true;
        }
      }
    }
    return false;
  }

  const addTask = async (task: string, additionMethod: AdditionMethodType, status?: StatusType, userPrompt?: string) => {
    const sourceId = uuidv4();
    await Highlight.vectorDB.insertItem(sourcesTableName, userPrompt ?? "", {sourceId: sourceId});

    // Add new task
    await Highlight.vectorDB.insertItem(tasksTableName, task, {
      status: status || 'pending',
      additionMethod: additionMethod,
      lastModified: new Date().toISOString(),
      sourceId: sourceId
    });

    if (additionMethod === 'automatically' && status !== 'false_positive') {
      await Highlight.app.showNotification('New task added to TODO list', task);
    }
    loadTasks();
  }

  // Helper function to calculate cosine similarity
  function cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, a, i) => sum + a * vec2[i], 0);
    const magnitude1 = Math.sqrt(vec1.reduce((sum, a) => sum + a * a, 0));
    const magnitude2 = Math.sqrt(vec2.reduce((sum, a) => sum + a * a, 0));
    return dotProduct / (magnitude1 * magnitude2);
  }

  useEffect(() => {
    const destructor = Highlight.app.addListener('onContext', async (context: HighlightContext) => {
      if (context.suggestion) {
        addTask(context.suggestion, 'semi_automatically');
      }
    })

    return () => {
      destructor();
    };
  });

  const grammar = `
    root ::= ("Task not assigned" | "Task assigned : " single-line)
    single-line ::= [^\n.]+ ("." | "\n")
    `;

  useEffect(() => {
    const onPeriodicForegroundAppCheck = async (context: FocusedWindow) => {
      if (!slmCapable) {
        return;
      }
      console.log(context);
      // Check if it is slack
      if (context.url?.includes("app.slack.com") || context.appName === "Slack") {
        const now = Date.now();
        if (now - lastCallTime.current >= 15000) { // 15 seconds
          lastCallTime.current = now;
          console.log("Slack is open");
          const context = await Highlight.user.getContext(true)
          let user_prompt = "\nName of the User : " + nameRef.current +  ".\nConversation : " + context.environment.ocrScreenContents;
          console.log("User Prompt : ", user_prompt);
          // replace all occurrences of @+name with empty string
          user_prompt = user_prompt.replace(new RegExp("@+" + nameRef.current, 'g'), nameRef.current);
          const slmTask = await Highlight.inference.getTextPredictionSlm(
            [{role: 'system', content: slm_system_prompt},
             {role: 'user', content: user_prompt}],
            grammar);
          console.log('slmTask : ', slmTask);
          if (slmTask.startsWith("Task assigned : ")) {
            const taskText = slmTask.replace("Task assigned : ", "");
            
            // Check for duplicate task
            const similarTasks = await Highlight.vectorDB.search(tasksTableName, taskText, 1);
            const duplicateTask = await isDuplicateTask(similarTasks, user_prompt);
            
            if (!duplicateTask) {
              // If not a duplicate, proceed with LLM and task addition
              const generator = Highlight.inference.getTextPrediction(
                [{role: 'system', content: llm_system_prompt},
                 {role: 'user', content: user_prompt}]);
              let llmTask: string = '';

              for await (const part of generator) {
                llmTask += part;
              }
              console.log('llmTask : ', llmTask);
              if (!llmTask.includes("Task not assigned") && /Task assigned\s*:\s*/.test(llmTask)) {
                const taskText = llmTask.replace(/Task assigned\s*:\s*/, "");
                await addTask(taskText, 'automatically', 'pending', user_prompt);
              } else {
                await addTask(taskText, 'automatically', 'false_positive', user_prompt);
              }
            } else {
              console.log("Duplicate task detected, skipping addition");
            }
          }
        } else {
          // console.log("Throttled: Context fetch not allowed yet");
        }
      }
    };

    //let removeListener = Highlight.app.addListener("onContext", onContext);
    let removeListener = Highlight.app.addListener("onPeriodicForegroundAppCheck", onPeriodicForegroundAppCheck);

    return () => {
      removeListener();
    };
  });

  useEffect(() => {
    loadTasks();
  }, []);

  const addTodo = async () => {
    if (newTodo.trim() === "") {
      return;
    }
    await addTask(newTodo, 'manually');
    setNewTodo("");
  }

  const updateTodo = async (id: string, text: string) => {
    const todo = todos.find(todo => todo.id === id);
    await Highlight.vectorDB.updateText(tasksTableName, id, text,
      { status: todo?.status,
        additionMethod: todo?.additionMethod,
        lastModified: new Date().toISOString() });
    loadTasks();
  }

  const toggleTodo = async (id: string) => {
    const todo = todos.find(todo => todo.id === id);
    const newStatus = todo?.status === 'completed' ? 'pending' : 'completed';
    await Highlight.vectorDB.updateMetadata(tasksTableName, id,
      { status: newStatus,
        additionMethod: todo?.additionMethod,
        lastModified: new Date().toISOString() });
    loadTasks();
  }

  const toggleTodoWithFadeOut = async (id: string) => {
    // Find the todo item and update its 'fadingOut' state temporarily
    const updatedTodos = todos.map(todo => {
      if (todo.id === id) {
        return { ...todo, fadingOut: true }; // Add a fadingOut property
      }
      return todo;
    });
    setTodos(updatedTodos);
    setTimeout(async () => {
      toggleTodo(id);
    }, 1000); // Delay of 1 second for the fade-out effect
  };

  const deleteTodo = async (id: string) => {
    const additionMethod = todos.find(todo => todo.id === id)?.additionMethod;
    if (additionMethod === 'automatically') {
      // For automatically added tasks, update the status to 'deleted' instead of deleting, so that we don't add it again
      await Highlight.vectorDB.updateMetadata(tasksTableName, id,
        { status: 'deleted',
          additionMethod: additionMethod,
          lastModified: new Date().toISOString() });
    } else {
      await Highlight.vectorDB.deleteItem(tasksTableName, id);
    }
    loadTasks();
  };

  const toggleHelp = async () => {
    await Highlight.appStorage.set("showHelpSection", !showHelpSection);
    setShowHelpSection(!showHelpSection);
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-background">
      {/* Todo List Box */}
      <div className="w-full max-w-4xl p-6 bg-card rounded-lg shadow-md relative mb-4">
        <div className="absolute top-4 right-4 flex items-center space-x-2">
          <UserIcon className="w-5 h-5" />
          {isEditingName ? (
            <div className="flex items-center">
              <Input
                type="text"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                className="bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              />
              <Button
                onClick={() => handleUserNameSave(userName)}
                className="bg-primary text-primary-foreground rounded-md px-3 py-2 ml-2"
              >
                Save
              </Button>
            </div>
          ) : (
            <div className="cursor-pointer hover:underline" onClick={handleUserNameEdit}>
              {name}
            </div>
          )}
        </div>
        <h1 className="text-2xl font-bold mb-4 text-card-foreground">Todo List</h1>
        <div className="flex items-center mb-4">
          <Input
            type="text"
            placeholder="Add a new todo"
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                addTodo()
              }
            }}
            className="flex-1 mr-2 bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
          />
          <Button onClick={addTodo} className="bg-primary text-primary-foreground rounded-md px-3 py-2">
            Add
          </Button>
        </div>
        <div className="space-y-2">
          {incompleteTodos.map((todo) => (
            <TodoItem
              key={todo.id}
              todo={todo}
              onCheckedChange={toggleTodoWithFadeOut}
              onDelete={deleteTodo}
              onUpdate={updateTodo}
            />
          ))}
        </div>
        <Collapsible
          open={showCompletedTodos}
          onOpenChange={() => setShowCompletedTodos(!showCompletedTodos)}
          className="mt-4"
        >
          <div className="flex justify-end">
            <CollapsibleTrigger className="flex items-center bg-muted rounded-md px-3 py-2 cursor-pointer justify-between">
              <div className="flex items-center">
                {showCompletedTodos ? (
                    <>
                      <ChevronDownIcon className="w-4 h-4 mr-2" />
                      Hide Completed Items
                    </>
                  ) : (
                    <>
                      <ChevronRightIcon className="w-4 h-4 mr-2" />
                      Show Completed Items
                    </>
                  )}
              </div>
            </CollapsibleTrigger>
          </div>
          <CollapsibleContent className="space-y-2 mt-2">
            {completedTodos.map((todo) => (
              <TodoItem
                key={todo.id}
                todo={todo}
                onCheckedChange={toggleTodo}
                onDelete={deleteTodo}
                onUpdate={updateTodo}
              />
            ))}
          </CollapsibleContent>
        </Collapsible>
      </div>
      {/* Help Section */}
      {showHelpSection && (
        <div className="w-full max-w-4xl p-6 bg-card rounded-lg shadow-md relative">
          <h2 className="text-xl font-bold mb-4 text-card-foreground">How to Use</h2>
          <button onClick={toggleHelp} className="absolute top-1 right-1 text-muted-foreground hover:text-card-foreground">
            <CloseIcon />
          </button>
          <div className="mb-2">
            <h3 className="text-lg font-bold mb-2">Semi Automatic</h3>
            <ul className="list-disc pl-4 space-y-2">
              <li>To add a new todo, simply press <i>{hotKey}</i> while working on any application.</li>
              <li>In the highlight popup, use <i>Tab</i> key <b>OR</b> <i>click the drop down</i> to select <b>Todo List</b> app</li>
              <li>Now the Todo suggestions should get listed based the your screen contents. Simply click the suitable suggestion to add it to the <b>Todo List</b></li>
            </ul>
          </div>
          <div className="mb-2">
            <h3 className="text-lg font-bold mb-2">Fully Automatic</h3>
            <ul className="list-disc pl-4 space-y-2">
              {slmCapable ? (
                <>
                  <li>Just sit back and relax. We will automatically add items the <b>Todo list</b> based on your screen contents.</li>
                  <li>Just ensure you have notification enabled for Highlight in your OS settings.</li>
                  <li>We will send a notification whenever we add an item to your <b>Todo list</b></li>
                  <li>Currently fully automatic mode is supported only for Slack. Support for more apps coming soon.</li>
                </>
              ) : (
                <li>Sorry. Your device does not support fully automatic task detection.</li>
              )}
            </ul>
          </div>
        </div>
      )}
      {/* "?" Button */}
      {!showHelpSection && (
        <button onClick={toggleHelp} className="fixed bottom-4 right-4 text-muted-foreground hover:text-card-foreground">
          <QuestionIcon />
        </button>
      )}
    </div>
  )
}

function ChevronRightIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m9 18 6-6-6-6" />
    </svg>
  )
}

function ChevronDownIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="m6 9 6 6 6-6" />
    </svg>
  )
}

function Trash2Icon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 6h18" />
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
      <line x1="10" x2="10" y1="11" y2="17" />
      <line x1="14" x2="14" y1="11" y2="17" />
    </svg>
  )
}

function CloseIcon() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  );
}

function QuestionIcon() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <path d="M12 19h0" />
      <path d="M9.09 9a3 3 0 0 1 5.83-1c.11.21.18.45.18.7 0 1.11-1.47 1.61-2.18 2.22-.52.45-.83.78-.83 1.36v.93" />
      <circle cx="12" cy="12" r="10" />
    </svg>
  );
}

function UserIcon(props: any) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
      <circle cx="12" cy="7" r="4" />
    </svg>
  )
}