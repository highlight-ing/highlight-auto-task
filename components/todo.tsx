/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/cthBC3Tlnxc
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client"

import { useEffect, useState, useRef, useMemo } from "react";
import { Card, CardContent } from '@/components/ui/card';
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Plus,
  Search,
  Tag,
  Trash2,
  AlertCircle,
  ChevronDown,
  MoreVertical,
  CheckCircle2,
  Circle,
  UserIcon,
  Moon,
  Sun,
  X,
  Link,
  Copy,
  Calendar,
  Bell,
  Settings
} from 'lucide-react';
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@/components/ui/collapsible"
import Highlight, { type HighlightContext, type FocusedWindow, type ConversationData } from "@highlight-ai/app-runtime";
import { useName } from './providers/NameProvider'; // Adjust the path based on where you save the context
import { v4 as uuidv4 } from 'uuid';
import { tasks_system_prompt_slm, tasks_system_prompt_llm, conversations_system_prompt, overall_conversations_system_prompt } from './prompts';
import { useTheme } from "next-themes"
import { DayPicker } from 'react-day-picker'
import { format } from 'date-fns'
import { cn } from "@/lib/utils"
import { createPortal } from 'react-dom'
import { ReminderModal } from "@/components/ui/reminder-modal"
import { RemindersView } from "@/components/reminders-view"
import { useReminders } from "./providers/RemindersProvider"

type StatusType = 'pending' | 'completed' | 'deleted' | 'false_positive';
type AdditionMethodType = 'manually' | 'automatically' | 'semi_automatically';

export interface Task {
  id: string;
  text: string;
  status: StatusType;
  additionMethod: AdditionMethodType;
  fadingOut: boolean;
  lastModified: string;
  priority: 'high' | 'medium' | 'low';
  sourceId: string;
  tags: string[];  // Changed from single category to multiple tags
  assignedBy?: string;
  source?: string;
  dueDate?: string; // Add this field
  reminders?: Reminder[]
}

interface TodoItemProps {
  todo: Task;
  onCheckedChange: (id: string) => void;
  onDelete: (id: string) => void;
  onUpdate: (id: string, text: string) => void;
  onAddTag: (todoId: string, tag: string) => void;
  onRemoveTag: (todoId: string, tag: string) => void; // Add this
  onUpdateDueDate: (id: string, date: string | undefined) => void; // Add this
  allTags: Set<string>;
  isCalendarOpen: boolean;
  onCalendarOpenChange: (isOpen: boolean) => void;
  onAddReminder: (taskId: string) => void;
}

interface DetectedTask {
  id: string
  metadata: Record<string, any>
  text: string
}

interface DetectedTasksCardProps {
  tasks: DetectedTask[]
  onAccept: (task: DetectedTask) => void
  onDecline: (task: DetectedTask) => void
}

interface TaskSummary {
  taskId: string
  summary: string
  timestamp: string
}

interface Reminder {
  id: string
  taskId: string
  time: string // ISO string
  type: 'custom' | '1_hour_before' | '1_day_before' | 'at_due_time'
  status: 'pending' | 'sent' | 'dismissed' | 'snoozed'
  lastNotified?: string
  snoozeUntil?: string
}

const TodoItem: React.FC<TodoItemProps> = ({ todo, onCheckedChange, onDelete, onUpdate, onAddTag, onRemoveTag, onUpdateDueDate, allTags, isCalendarOpen, onCalendarOpenChange, onAddReminder }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  const [isAddingTag, setIsAddingTag] = useState(false);
  const [newTag, setNewTag] = useState("");
  const [filteredTags, setFilteredTags] = useState<string[]>([]);
  const tagInputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const tagPopupRef = useRef<HTMLDivElement>(null);
  const todoItemRef = useRef<HTMLDivElement>(null);
  const [showAbove, setShowAbove] = useState(false);
  const calendarRef = useRef<HTMLDivElement>(null);

  const priorityColors = {
    high: 'bg-red-50 border-red-200 hover:bg-red-100',
    medium: 'bg-yellow-50 border-yellow-200 hover:bg-yellow-100',
    low: 'bg-green-50 border-green-200 hover:bg-green-100'
  };

  const categoryColors = {
    Development: 'text-purple-600 bg-purple-100',
    Bugs: 'text-red-600 bg-red-100',
    Feature: 'text-blue-600 bg-blue-100',
    Design: 'text-green-600 bg-green-100'
  };

  // Get existing tags once
  const existingTags = useMemo(() =>
    Array.from(allTags).filter(tag => !todo.tags?.includes(tag)),
    [allTags, todo.tags]
  );

  // Update filtered tags when search changes
  useEffect(() => {
    if (newTag.trim()) {
      const filtered = existingTags.filter(tag =>
        tag.toLowerCase().includes(newTag.toLowerCase())
      );
      setFilteredTags(filtered);
    } else {
      setFilteredTags(existingTags);
    }
  }, [newTag, existingTags]); // Only depend on newTag and existingTags

  // Update edit text when todo changes
  useEffect(() => {
    setEditText(todo.text);
  }, [todo.text]);

  // Handle popup position
  useEffect(() => {
    const updatePopupPosition = () => {
      if (todoItemRef.current && tagPopupRef.current) {
        const todoRect = todoItemRef.current.getBoundingClientRect();
        const popupHeight = tagPopupRef.current.offsetHeight;
        const viewportHeight = window.innerHeight;
        const spaceBelow = viewportHeight - todoRect.bottom;
        setShowAbove(spaceBelow < (popupHeight + 10));
      }
    };

    if (isAddingTag) {
      updatePopupPosition();
      window.addEventListener('scroll', updatePopupPosition, true);
      window.addEventListener('resize', updatePopupPosition);
    }

    return () => {
      window.removeEventListener('scroll', updatePopupPosition, true);
      window.removeEventListener('resize', updatePopupPosition);
    };
  }, [isAddingTag]); // Only depend on isAddingTag

  // Handle click outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (isAddingTag &&
          tagPopupRef.current &&
          !tagPopupRef.current.contains(e.target as Node)) {
        setIsAddingTag(false);
        setNewTag("");
      }
    };

    if (isAddingTag) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isAddingTag]); // Only depend on isAddingTag

  // Focus tag input when adding
  useEffect(() => {
    if (isAddingTag && tagInputRef.current) {
      tagInputRef.current.focus();
    }
  }, [isAddingTag]); // Only depend on isAddingTag

  const handleTagSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTag.trim()) {
      onAddTag(todo.id, newTag.trim());
      setNewTag("");
      setIsAddingTag(false);
    }
  };

  const handleTagSelect = (tag: string) => {
    onAddTag(todo.id, tag);
    setNewTag("");
    setIsAddingTag(false);
  };

  const handleTagKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Escape') {
      setIsAddingTag(false);
      setNewTag("");
    } else if (e.key === 'ArrowDown' && filteredTags.length > 0) {
      e.preventDefault();
      const firstTag = dropdownRef.current?.querySelector('button');
      firstTag?.focus();
    }
  };

  const handleClick = () => setIsEditing(true);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEditText(e.target.value);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      if (e.key === 'Enter') {
        onUpdate(todo.id, editText);
      }
      setIsEditing(false);
      setEditText(todo.text);
    }
  };

  const handleBlur = () => {
    onUpdate(todo.id, editText);
    setIsEditing(false);
  };

  const handleCalendarClick = () => {
    onCalendarOpenChange(!isCalendarOpen)
  }

  // Add click outside handler
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        isCalendarOpen &&
        calendarRef.current &&
        !calendarRef.current.contains(event.target as Node)
      ) {
        onCalendarOpenChange(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isCalendarOpen, onCalendarOpenChange]);

  useEffect(() => {
    const positionCalendar = () => {
      if (calendarRef.current && todoItemRef.current) {
        const buttonRect = todoItemRef.current.getBoundingClientRect()
        const calendarRect = calendarRef.current.getBoundingClientRect()
        const viewportWidth = window.innerWidth
        const viewportHeight = window.innerHeight

        // Calculate position
        let top = buttonRect.bottom + 8
        let left = buttonRect.right - calendarRect.width

        // Ensure calendar stays within viewport
        if (top + calendarRect.height > viewportHeight) {
          top = buttonRect.top - calendarRect.height - 8
        }

        if (left < 0) {
          left = 8
        } else if (left + calendarRect.width > viewportWidth) {
          left = viewportWidth - calendarRect.width - 8
        }

        // Apply position
        calendarRef.current.style.top = `${top}px`
        calendarRef.current.style.left = `${left}px`
      }
    }

    if (isCalendarOpen) {
      requestAnimationFrame(positionCalendar)
      window.addEventListener('scroll', positionCalendar, true)
      window.addEventListener('resize', positionCalendar)
    }

    return () => {
      window.removeEventListener('scroll', positionCalendar, true)
      window.removeEventListener('resize', positionCalendar)
    }
  }, [isCalendarOpen])

  return (
    <div
      ref={todoItemRef}
      className="group relative bg-white/50 dark:bg-gray-800/50 rounded-xl border border-gray-100 dark:border-gray-700/50 p-3.5 transition-all duration-200 hover:shadow-md dark:hover:bg-gray-800/80"
    >
      <div className="flex items-start gap-3">
        <button
          onClick={() => onCheckedChange(todo.id)}
          className="flex-shrink-0 mt-1 focus:outline-none"
        >
          {todo.status === 'completed' ? (
            <CheckCircle2 className="w-5 h-5 text-blue-500 dark:text-blue-400" />
          ) : (
            <Circle className="w-5 h-5 text-gray-400 group-hover:text-blue-500 dark:group-hover:text-blue-400 transition-colors" />
          )}
        </button>

        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            {isEditing ? (
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                onKeyDown={handleKeyDown}
                onBlur={handleBlur}
                className="flex-grow px-2 py-1 text-sm rounded-md border dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
                autoFocus
              />
            ) : (
              <span
                className={`text-base font-medium truncate cursor-pointer ${
                  todo.status === 'completed'
                    ? 'line-through text-gray-400 dark:text-gray-500'
                    : 'text-gray-900 dark:text-gray-100'
                }`}
                onClick={() => setIsEditing(true)}
              >
                {todo.text}
              </span>
            )}
          </div>

          {/* Updated Tags display with better spacing */}
          {todo.tags && todo.tags.length > 0 && (
            <div className="flex flex-wrap gap-1 mt-1 mb-2">
              {todo.tags.map((tag) => (
                <span
                  key={tag}
                  className="inline-flex items-center text-xs font-medium rounded-full bg-blue-100/80 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300 group/tag"
                >
                  <span className="px-2 py-0.5">#{tag}</span>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onRemoveTag(todo.id, tag);
                    }}
                    className="w-0 group-hover/tag:w-4 overflow-hidden transition-all duration-200 hover:bg-blue-200 dark:hover:bg-blue-800 rounded-r-full"
                  >
                    <X className="w-3 h-3 mx-0.5" />
                  </button>
                </span>
              ))}
            </div>
          )}

          {/* Metadata section with consistent spacing */}
          <div className="space-y-1 text-xs text-gray-500 dark:text-gray-400">
            {((todo.assignedBy && todo.assignedBy !== 'unknown') || todo.source) && (
              <div className="flex items-center gap-2">
                {todo.assignedBy && todo.assignedBy !== 'unknown' && (
                  <div className="flex items-center gap-1">
                    <UserIcon className="w-3 h-3" />
                    <span>Assigned by {todo.assignedBy}</span>
                  </div>
                )}
                {todo.source && (
                  <div className="flex items-center gap-1">
                    <Link className="w-3 h-3" />
                    <span>From {todo.source}</span>
                  </div>
                )}
              </div>
            )}
            {todo.dueDate && (
              <div className="flex items-center gap-1">
                <Calendar className="w-3 h-3" />
                <span>Due {format(new Date(todo.dueDate), 'do MMM')}</span>
              </div>
            )}
          </div>
        </div>

        <div className="flex items-center gap-2">
          <div className="opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-1">
            <Button
              variant="ghost"
              size="sm"
              className="text-gray-500 hover:text-red-600 p-1"
              onClick={() => onDelete(todo.id)}
            >
              <Trash2 className="w-4 h-4" />
            </Button>
          </div>
          {todo.status !== 'completed' && <div className="flex flex-col gap-1">
            <Button
              variant="ghost"
              size="sm"
              className={`flex items-center gap-1 px-2 ${
                todo.dueDate
                  ? 'text-blue-600 dark:text-blue-400'
                  : 'text-gray-500 hover:text-gray-700'
              }`}
              onClick={handleCalendarClick}
            >
              <Calendar className="w-4 h-4" />
              <span className="text-xs">
                {todo.dueDate ? 'Edit due date' : 'Add due date'}
              </span>
            </Button>
            <Button
              variant="ghost"
              size="sm"
              className="flex items-center gap-1 px-2 text-gray-500 hover:text-gray-700"
              onClick={() => onAddReminder(todo.id)}
            >
              <Bell className="w-4 h-4" />
              <span className="text-xs">
                Add reminder
              </span>
            </Button>
          </div>}
        </div>
      </div>

      {/* Tag Popup */}
      {isAddingTag && (
        <div
          ref={tagPopupRef}
          className={`absolute ${
            showAbove
              ? 'bottom-full mb-2'
              : 'top-full mt-2'
          } right-0 z-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg dark:shadow-gray-900/50`}
        >
          <div className="p-2">
            <form onSubmit={handleTagSubmit} className="flex items-center gap-2">
              <Input
                ref={tagInputRef}
                type="text"
                placeholder="Add tag..."
                value={newTag}
                onChange={(e) => setNewTag(e.target.value)}
                onKeyDown={handleTagKeyDown}
                className="text-sm w-48 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:placeholder-gray-400"
                autoFocus
              />
              <Button
                type="submit"
                size="sm"
                variant="ghost"
                className="text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300"
              >
                Add
              </Button>
            </form>
          </div>

          {/* Existing Tags Dropdown */}
          {filteredTags.length > 0 && (
            <div
              ref={dropdownRef}
              className="border-t dark:border-gray-700 overflow-y-auto p-1"
            >
              {filteredTags.map((tag) => (
                <button
                  key={tag}
                  onClick={() => handleTagSelect(tag)}
                  className="w-full text-left px-3 py-1.5 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700/50 rounded-md focus:bg-gray-100 dark:focus:bg-gray-700/50 focus:outline-none flex items-center gap-2"
                >
                  <Tag className="w-3 h-3" />
                  <span>{tag}</span>
                </button>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Add due date popup */}
      {isCalendarOpen && createPortal(
        <div
          ref={calendarRef}
          className="fixed z-50 bg-white dark:bg-gray-800 rounded-lg shadow-lg dark:shadow-gray-900/50 w-[280px]"
        >
          <div className="p-3">
            <DayPicker
              mode="single"
              selected={todo.dueDate ? new Date(todo.dueDate) : undefined}
              onSelect={(date) => {
                onUpdateDueDate(todo.id, date ? format(date, 'yyyy-MM-dd') : undefined)
                onCalendarOpenChange(false)
              }}
              showOutsideDays={false}
              className={cn(
                "p-0",
                "dark:bg-gray-800 dark:text-gray-100",
                // Month navigation and header
                "[&_.rdp-caption]:flex [&_.rdp-caption]:items-center [&_.rdp-caption]:justify-between [&_.rdp-caption]:mb-2",
                "[&_.rdp-caption_div]:flex [&_.rdp-caption_div]:items-center [&_.rdp-caption_div]:gap-2",
                // Navigation buttons
                "[&_.rdp-nav]:flex [&_.rdp-nav]:items-center [&_.rdp-nav]:gap-1",
                "[&_.rdp-nav_button]:h-7 [&_.rdp-nav_button]:w-7 [&_.rdp-nav_button]:rounded-md [&_.rdp-nav_button]:transition-colors",
                "[&_.rdp-nav_button]:hover:bg-gray-100 dark:[&_.rdp-nav_button]:hover:bg-gray-700",
                "[&_.rdp-nav_button]:active:bg-gray-200 dark:[&_.rdp-nav_button]:active:bg-gray-600",
                // Table styles
                "[&_table]:w-full [&_table]:border-collapse",
                // Weekday header
                "[&_thead_th]:text-xs [&_thead_th]:font-medium [&_thead_th]:text-gray-500 dark:[&_thead_th]:text-gray-400",
                // Day cells
                "[&_td]:p-0 [&_td]:text-center [&_td]:text-sm",
                // Day buttons
                "[&_.rdp-button]:h-10 [&_.rdp-button]:w-10 [&_.rdp-button]:rounded-full [&_.rdp-button]:transition-colors",
                "[&_.rdp-button]:hover:bg-blue-100 dark:[&_.rdp-button]:hover:bg-blue-800/50",
                "[&_.rdp-button]:focus:bg-blue-100 dark:[&_.rdp-button]:focus:bg-blue-800/50",
                // Selected day
                "[&_.rdp-day_button.rdp-day_selected]:bg-blue-600 [&_.rdp-day_button.rdp-day_selected]:text-white",
                "[&_.rdp-day_button.rdp-day_selected]:hover:bg-blue-700",
                "[&_.rdp-day_button.rdp-day_selected]:rounded-full",
                // Today's date style
                "[&_.rdp-day_today]:font-medium [&_.rdp-day_today]:bg-gray-100/80 dark:[&_.rdp-day_today]:bg-gray-800",
                "[&_.rdp-day_today]:rounded-full",
                // Update navigation button colors
                "[&_.rdp-nav_button]:text-white dark:[&_.rdp-nav_button]:text-gray-100",
                // Add hover styles for days
                "[&_.rdp-day_button:hover]:bg-blue-50 dark:[&_.rdp-day_button:hover]:bg-blue-900/25",
                "[&_.rdp-day_button:hover]:rounded-full",
                "[&_.rdp-day_button:focus]:bg-blue-50 dark:[&_.rdp-day_button:focus]:bg-blue-900/25",
                "[&_.rdp-day_button:focus]:rounded-full",
                "[&_.rdp-day_button]:transition-all duration-200",
                // More visible hover state
                "[&_.rdp-day_button:hover]:bg-blue-100 dark:[&_.rdp-day_button:hover]:bg-blue-800/50",
                "[&_.rdp-day_button:focus]:bg-blue-100 dark:[&_.rdp-day_button:focus]:bg-blue-800/50",
                // Selected state with matching style
                "[&_.rdp-day_button.rdp-day_selected]:bg-blue-600",
                "[&_.rdp-day_button.rdp-day_selected]:hover:bg-blue-700",
                "[&_.rdp-day_button.rdp-day_selected]:rounded-full",
                // Today's date style
                "[&_.rdp-day_today]:font-medium [&_.rdp-day_today]:bg-gray-100/80 dark:[&_.rdp-day_today]:bg-gray-800",
                "[&_.rdp-day_today]:rounded-full"
              )}
              classNames={{
                caption: "flex items-center justify-between px-1",
                caption_label: "text-sm font-medium",
                nav: "flex items-center gap-1",
                nav_button: "h-7 w-7 inline-flex items-center justify-center rounded-md transition-colors hover:bg-gray-100 dark:hover:bg-gray-700",
                head_cell: "text-xs font-medium text-gray-500 dark:text-gray-400 py-2",
                button: "hover:bg-blue-100 dark:hover:bg-blue-800/50 rounded-full transition-all duration-200"
              }}
            />
            <div className="flex justify-end gap-2 mt-2 pt-2 border-t dark:border-gray-700">
              {todo.dueDate && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    onUpdateDueDate(todo.id, undefined)
                    onCalendarOpenChange(false)
                  }}
                  className="text-red-500 hover:text-red-600 hover:bg-red-50 dark:text-red-400 dark:hover:text-red-300 dark:hover:bg-red-950/50 transition-colors"
                >
                  <Trash2 className="w-4 h-4 mr-1.5" />
                  Remove
                </Button>
              )}
              <Button
                size="sm"
                variant="ghost"
                onClick={() => onCalendarOpenChange(false)}
                className="text-gray-600 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-gray-300 dark:hover:bg-gray-700 transition-colors"
              >
                <X className="w-4 h-4 mr-1.5" />
                Cancel
              </Button>
            </div>
          </div>
        </div>,
        document.body
      )}
    </div>
  );
};

function DetectedTasksCard({ tasks, onAccept, onDecline }: DetectedTasksCardProps) {
  if (tasks.length === 0) return null

  return (
    <Card className="w-80 h-fit bg-white/80 dark:bg-gray-900/80 backdrop-blur-lg shadow-xl rounded-2xl overflow-hidden border-0 dark:ring-1 dark:ring-white/10">
      <div className="p-4 border-b dark:border-gray-800">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-gray-100">
          Detected Tasks
        </h2>
      </div>
      <CardContent className="p-4">
        <div className="space-y-4 mt-2">
          {tasks.map((task) => (
            <div
              key={task.id}
              className="bg-white/50 dark:bg-gray-800/50 rounded-lg p-4 border border-gray-100 dark:border-gray-700/50"
            >
              <p className="text-gray-900 dark:text-gray-100 mb-4">{task.text}</p>
              <div className="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400 mb-4">
                <UserIcon className="w-4 h-4" />
                <span>By {task.metadata.assignedBy}</span>
                <Link className="w-4 h-4" />
                <span>From {task.metadata.source}</span>
              </div>
              <div className="flex gap-2">
                <Button
                  onClick={() => onAccept(task)}
                  className="flex-1 bg-gradient-to-r from-green-600 to-emerald-600 hover:opacity-90 text-white dark:from-green-500 dark:to-emerald-500"
                >
                  <CheckCircle2 className="w-4 h-4 mr-2" />
                  Accept
                </Button>
                <Button
                  onClick={() => onDecline(task)}
                  variant="outline"
                  className="flex-1 border-red-200 text-red-600 hover:bg-red-50 dark:border-red-800 dark:text-red-400 dark:hover:bg-red-950/50"
                >
                  <X className="w-4 h-4 mr-2" />
                  Decline
                </Button>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}

export function Todo() {
  const lastAppsCheckTime = useRef(0);
  const lastConversationsCheckTime = useRef(0);
  const [todos, setTodos] = useState<Task[]>([]);
  const [newTodo, setNewTodo] = useState("")
  const { name, handleNameUpdate } = useName();
  const { reminders } = useReminders();
  const [ userName, setUserName] = useState(name);
  const nameRef = useRef(name);
  const [searchQuery, setSearchQuery] = useState("");
  const [inputText, setInputText] = useState("");

  const [isEditingName, setIsEditingName] = useState(false)
  const [showCompletedTodos, setShowCompletedTodos] = useState(false)
  const [showHelpSection, setShowHelpSection] = useState(false)
  const [hotKey, setHotKey] = useState("")
  const [slmCapable, setSlmCapable] = useState(false);
  const [newTaskText, setNewTaskText] = useState("");

  const tasksTableName = "tasks";
  const sourcesTableName = "sources";
  const detectedTasksTableName = "detectedTasks";

  const [allTags, setAllTags] = useState<Set<string>>(new Set());
  const [activeTag, setActiveTag] = useState<string>("all");
  const [isAddingTag, setIsAddingTag] = useState<{todoId: string; isOpen: boolean}>({ todoId: '', isOpen: false });
  const { theme, setTheme } = useTheme()

  const [detectedTasks, setDetectedTasks] = useState<DetectedTask[]>([])
  const [taskSummaries, setTaskSummaries] = useState<TaskSummary[]>([])
  const [isCopied, setIsCopied] = useState(false)

  const [isInitialized, setIsInitialized] = useState(false)

  const [openCalendarId, setOpenCalendarId] = useState<string | null>(null)
  const [showReminderModal, setShowReminderModal] = useState(false)
  const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null)

  const pendingReminders = reminders.filter(r =>
    r.status !== 'dismissed'
  )

  const [privacyChoice, setPrivacyChoice] = useState<'agree' | 'disagree' | null>(null)

  useEffect(() => {
    const initializeApp = async () => {
      try {
        // Load initial data
        await loadTasks()

        // Initialize name from storage if exists
        const savedName = await Highlight.appStorage.get('userName')
        if (savedName) {
          handleNameUpdate(savedName)
          nameRef.current = savedName
        }

        // Initialize help section state
        const helpSectionState = await Highlight.appStorage.get("showHelpSection")
        setShowHelpSection(helpSectionState ?? true)

        setIsInitialized(true)
      } catch (error) {
        console.error('Failed to initialize app:', error)
      }
    }

    initializeApp()
  }, []) // Empty deps array for initialization

  useEffect(() => {
    nameRef.current = name;
  }, [name]);

  useEffect(() => {
    Highlight.permissions.requestBackgroundPermission();
  }, []);

  useEffect(() => {
    const getShowHelpSection = async () => {
      const showHelp = await Highlight.appStorage.get("showHelpSection") ?? true;
      setShowHelpSection(showHelp);
    }
    getShowHelpSection();
  }, []);

  useEffect(() => {
    const isSlmCapable = async () => {
      setSlmCapable(await Highlight.inference.isSlmCapable());
    }
    isSlmCapable();
  }, []);

  useEffect(() => {
    const getHotKey = async () => {
      const hotKey = await Highlight.app.getHotkey();
      setHotKey(hotKey);
    }
    getHotKey();
  }, []);

  useEffect(() => {
    const loadPrivacyChoice = async () => {
      const choice = await Highlight.appStorage.get('privacyChoice')
      setPrivacyChoice(choice)
    }
    loadPrivacyChoice()
  }, [])

  const handleSettingsClick = () => {
    window.location.href = '/?settings=true'
  }

  // Load tasks from the VectorDB
  const loadTasks = async () => {
    try {
      const tasks = await Highlight.vectorDB.getAllItems(tasksTableName);
      const taskObjects = tasks.map((task) => ({
        id: task.id,
        text: task.text,
        status: task.metadata.status,
        additionMethod: task.metadata.additionMethod,
        lastModified: task.metadata.lastModified,
        fadingOut: false,
        priority: task.metadata.priority,
        sourceId: task.metadata.sourceId,
        tags: task.metadata.tags || [],
        assignedBy: task.metadata.assignedBy || 'unknown',
        source: task.metadata.source,
        dueDate: task.metadata.dueDate // Add this field
      }));

      // Collect all unique tags from tasks
      const tagsSet = new Set<string>();
      taskObjects.forEach(task => {
        if (task.tags) {
          task.tags.forEach((tag: string) => tagsSet.add(tag.toLowerCase()));
        }
      });

      setTodos(taskObjects);
      setAllTags(tagsSet); // Update allTags with collected tags
    } catch (error) {
      console.log("Error getting tasks: ", error);
    }
  };

  const loadDetectedTasks = async () => {
    try {
      const tasks = await Highlight.vectorDB.getAllItems(detectedTasksTableName);
      const pendingTasks = tasks
        .filter(task => task.metadata.status === 'pending')
        .map(task => ({
          id: task.id,
          metadata: task.metadata,
          text: task.text
        }));

      // Only update state if there's a difference in tasks
      const currentIds = new Set(detectedTasks.map(t => t.id));
      const newIds = new Set(pendingTasks.map(t => t.id));

      if (pendingTasks.length !== detectedTasks.length ||
          !pendingTasks.every(t => currentIds.has(t.id)) ||
          !detectedTasks.every(t => newIds.has(t.id))) {
        setDetectedTasks(pendingTasks);
        // console.log("Updated detected tasks:", pendingTasks);
      }
    } catch (error) {
      console.error("Failed to load detected tasks:", error);
    }
  };

  useEffect(() => {
    const init = async () => {
      await Promise.all([loadTasks(), loadDetectedTasks()])
    }
    init()
  }, [])

  const isDuplicateTask = async (taskText: string, userPrompt: string): Promise<boolean> => {
    // Search for only the most similar task
    const similarTasks = await Highlight.vectorDB.vectorSearch(tasksTableName, taskText, 1);

    if (similarTasks.length > 0 && Math.abs(similarTasks[0].distance) < 0.30) {
      const task = similarTasks[0];
      const metadata = JSON.parse(task.metadata);
      const existingSourceId = metadata.sourceId;

      // If task is pending, mark as duplicate immediately
      if (metadata.status === 'pending') {
        console.log("Similar task is already pending - marking as duplicate");
        return true;
      }

      if (userPrompt=='conversations') {
        return true;
      }

      // Get source similarity if sourceId exists
      if (existingSourceId) {
        const existingSources = await Highlight.vectorDB.getAllItems(sourcesTableName);
        const existingSource = existingSources.find(source => source.metadata.sourceId === existingSourceId);
        const existingSourceVector = existingSource?.vector;

        let newSourceEmbedding;
        try {
          newSourceEmbedding = await Highlight.inference.getEmbedding(userPrompt);
        } catch (error) {
          console.error("Error getting new source embedding: ", error);
          return false;
        }

        const similarity = cosineSimilarity(existingSourceVector, newSourceEmbedding);

        // Case 1: Task is completed/deleted and source is similar - mark as duplicate
        if ((metadata.status === 'completed' || metadata.status === 'deleted') && similarity > 0.85) {
          console.log("Task already completed with similar source - marking as duplicate");
          return true;
        }

        // Case 2: Task is completed/deleted but source is different - allow new task creation
        if ((metadata.status === 'completed' || metadata.status === 'deleted') && similarity <= 0.85) {
          console.log("Task was completed but has new source - allowing new task creation");
          return false;
        }
      }
    }

    // Then check detected tasks
    const similarDetectedTasks = await Highlight.vectorDB.vectorSearch(detectedTasksTableName, taskText, 1);
    if (similarDetectedTasks.length > 0 && Math.abs(similarDetectedTasks[0].distance) < 0.30) {
      console.log("Similar task already detected - skipping");
      return true;
    }

    return false;
  };

  const addTask = async (task: DetectedTask) => {
      await Highlight.vectorDB.insertItem(tasksTableName, task.text, task.metadata);

    if (task.metadata.status === 'pending') {
      loadTasks();
    }
  }

  const storeDetectedTask = async (taskText: string, assignedBy: string, userPrompt: string, appSource: string) => {
    try {
      const sanitizedText = taskText.replace(/["]/g, '')
      const sourceId = uuidv4()
      await Highlight.vectorDB.insertItem(sourcesTableName, userPrompt, { sourceId })

      const metadata = {
        status: 'pending',
        additionMethod: 'automatically',
        lastModified: new Date().toISOString(),
        sourceId,
        assignedBy,
        source: appSource
      }

      await Highlight.vectorDB.insertItem(detectedTasksTableName, sanitizedText, metadata)

      // Get the task ID from the DB immediately after insertion
      const tasks = await Highlight.vectorDB.getAllItems(detectedTasksTableName)
      const task = tasks.find(t => t.text === sanitizedText && t.metadata.sourceId === sourceId)
      if (!task) throw new Error(`Failed to find newly created task : ${sanitizedText}`)

      const newTask: DetectedTask = {
        id: task.id,
        metadata: task.metadata,
        text: task.text
      }

      setDetectedTasks(prev => [...prev, newTask])
      console.log("Task shown on UI :", newTask)
      await Highlight.app.showNotification('New task detected:', task.text);
      await Highlight.reporting.trackEvent('Task Detected', {
        source: appSource
      })
    } catch (error) {
      console.error("Failed to store detected task:", error)
      return null
    }
  }

  const handleAcceptTask = async (task: DetectedTask) => {
    await addTask(task)
    await Highlight.vectorDB.updateMetadata(detectedTasksTableName, task.id, {
      additionMethod: 'automatically',
      assignedBy: task.metadata.assignedBy || 'unknown',
      lastModified: new Date().toISOString(),
      sourceId: task.metadata.sourceId,
      status: 'accepted',
    })
    setDetectedTasks(prev => prev.filter(t => t.id !== task.id))
    await Highlight.reporting.trackEvent('Task Accepted', {
      source: task.metadata.source
    })
  }

  const handleDeclineTask = async (task: DetectedTask) => {
    await Highlight.vectorDB.updateMetadata(detectedTasksTableName, task.id, {
      additionMethod: 'automatically',
      assignedBy: task.metadata.assignedBy || 'unknown',
      lastModified: new Date().toISOString(),
      sourceId: task.metadata.sourceId,
      status: 'declined',
    })
    setDetectedTasks(prev => prev.filter(t => t.id !== task.id))
    await Highlight.reporting.trackEvent('Task Declined', {
      source: task.metadata.source
    })
  }

  // Helper function to calculate cosine similarity
  function cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, a, i) => sum + a * vec2[i], 0);
    const magnitude1 = Math.sqrt(vec1.reduce((sum, a) => sum + a * a, 0));
    const magnitude2 = Math.sqrt(vec2.reduce((sum, a) => sum + a * a, 0));
    return dotProduct / (magnitude1 * magnitude2);
  }

  useEffect(() => {
    const destructor = Highlight.app.addListener('onContext', async (context: HighlightContext) => {
      if (context.suggestion) {
        addTask({
          id: uuidv4(),
          metadata: { status: 'pending', additionMethod: 'semi_automatically' },
          text: context.suggestion
        })
        await Highlight.reporting.trackEvent('Task Added Semi-Automatically')
      }
    })

    return () => {
      destructor();
    };
  });

  const grammar = `
    root ::= ("Task not assigned" | "Task assigned : " single-line)
    single-line ::= [^\n.]+ ("." | "\n")
    `;

  useEffect(() => {
    if (!isInitialized) return

    const onPeriodicForegroundAppCheck = async (context: FocusedWindow) => {
      // If automatic features are disabled, don't run the checks
      if (privacyChoice === 'disagree') return

      const now = Date.now()
      if (now - lastAppsCheckTime.current >= 10000) {
        console.log("Starting periodic apps check...")

        // Handle apps flow first
        const supportedApps = [
          // Chat/Team Apps
          "Slack",
          "app.slack.com",
          "Microsoft Teams",
          "teams.microsoft.com",
          "Telegram",
          "telegram.org",
          "WhatsApp",
          "web.whatsapp.com",

          // Email Apps
          "Outlook",
          "outlook.office.com",
          "mail.google.com",
          "Superhuman",
          "Mail",
          "ProtonMail",
          "mail.proton.me",
          "Thunderbird"
        ]
        if (supportedApps.some(app =>
          context.appName === app ||
          (context.url && context.url.includes(app))
        )) {
          lastAppsCheckTime.current = now
          console.log("Processing supported app:", context.appName || context.url)
          const userContext = await Highlight.user.getContext(true)
          const screenContent = userContext.environment.ocrScreenContents ?? ""

          const userCount = (screenContent.match(new RegExp(`\\b${nameRef.current.split(' ')[0]}\\b`, 'gi')) || []).length
          if (userCount < 1) {
            console.log("User not found in screen content, skipping SLM call")
            return
          }

          // Check for duplicate screen content
          const isDuplicateScreen = false // await isDuplicateTask(screenContent, screenContent)
          if (!isDuplicateScreen) {
            let user_prompt = `Name of the User : ${nameRef.current.split(' ')[0]}.\nConversation : ${screenContent}`
            const slmTask = await Highlight.inference.getTextPredictionSlm(
              [{role: 'system', content: tasks_system_prompt_slm},
              {role: 'user', content: user_prompt}],
              grammar
            )

            if (slmTask.startsWith("Task assigned : ")) {
              const slmTaskText = slmTask.replace("Task assigned : ", "")
              console.log("SLM found potential task:", slmTaskText)

              const isDuplicateSlmTask = await isDuplicateTask(slmTaskText, user_prompt)
              if (!isDuplicateSlmTask) {
                console.log("Running LLM verification...")
                user_prompt = `Date Range: ${new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} to ${new Date().toISOString().split('T')[0]}.\n${user_prompt}`
                const generator = Highlight.inference.getTextPrediction(
                  [{role: 'system', content: tasks_system_prompt_llm},
                  {role: 'user', content: user_prompt}]
                )

                let llmTask = ''
                for await (const part of generator) {
                  llmTask += part
                }

                if (llmTask.includes("Task assigned : ")) {
                  let llmTaskText = llmTask.replace(/Task assigned\s*:\s*/, "")
                  const llmAssignedBy = llmTaskText.split(" Assigned by ")[1].replace(',', '').trim()
                  llmTaskText = llmTaskText.split(" Assigned by ")[0].replace(',', '').trim()
                  if (llmAssignedBy.split(' ')[0] == nameRef.current.split(' ')[0]) {
                    console.log("LLM task assigned to self, skipping addition")
                    return
                  }

                  const isDuplicateLlmTask = await isDuplicateTask(llmTaskText, user_prompt)
                  if (!isDuplicateLlmTask) {
                    await storeDetectedTask(llmTaskText, llmAssignedBy, user_prompt, context.appName || new URL(context.url || '').hostname)
                  } else {
                    console.log("Duplicate LLM task detected from apps, skipping addition")
                  }
                } else {
                  console.log("No task found by LLM")
                }
              } else {
                console.log("Duplicate SLM task detected from apps, skipping LLM call")
              }
            } else {
              console.log("No task found in SLM")
            }
          } else {
            console.log("Duplicate screen content detected, skipping SLM call")
          }
        }
        console.log("Periodic check for apps completed")
      }
    }

    let removeListener: (() => void) | undefined

    // Only add the listener if automatic features are enabled
    if (privacyChoice === 'agree') {
      removeListener = Highlight.app.addListener(
        "onPeriodicForegroundAppCheck",
        onPeriodicForegroundAppCheck
      )
    }

    return () => {
      if (removeListener) {
        removeListener()
      }
    }
  }, [isInitialized, privacyChoice]) // Add privacyChoice to dependencies

  useEffect(() => {
    if (!isInitialized) return

    const onConversationSaved = async (conversation: ConversationData) => {
      const recentTranscripts = conversation.transcript

      // // Check if conversation is one-sided
      // const selfCount = (recentTranscripts.match(/self:/gi) || []).length
      // // change other to other(s):
      // const otherCount = (recentTranscripts.match(/other\(s\):/gi) || []).length

      // // If only self messages or no messages at all, skip processing
      // if (selfCount > 0 && otherCount === 0) {
      //   console.log("Skipping one-sided conversation")
      //   return
      // }

      const conversations_prompt = [
        `Name of the User: ${nameRef.current}`,
        `Recent Conversations: ${recentTranscripts}`
      ].join("\n")

      console.log("Running LLM for conversations for user: ", nameRef.current)
      const user_generator = Highlight.inference.getTextPrediction(
        [{role: 'system', content: conversations_system_prompt},
        {role: 'user', content: conversations_prompt}],
        {temperature: 0.5}
      )

      let user_llmTask = ''
      for await (const part of user_generator) {
        user_llmTask += part
      }

      console.log("User Conversations LLM task:", user_llmTask)

      if (user_llmTask.startsWith('[') && user_llmTask.endsWith(']')) {
        try {

          const tasks = user_llmTask
            .slice(1, -1)
            .split('",')
            .map(task => task.replace(/^"|"$/g, '').trim())

          console.log("Tasks:", tasks)

          for (const task of tasks) {
            if (task.includes("Task assigned : ")) {
              const taskText = task.replace(/Task assigned\s*:\s*/, "").trim()
              console.log("LLM found potential task from conversations:", taskText)

              const isDuplicateLlmTask = await isDuplicateTask(taskText, 'conversations')
              if (!isDuplicateLlmTask) {
                await storeDetectedTask(taskText, "unknown", 'conversations', "Meeting")
              } else {
                console.log("Duplicate task detected from conversations, skipping addition")
              }
            }
          }
        } catch (error) {
          console.error("Failed to parse tasks array:", error)
        }
      } else if (user_llmTask.includes("Task assigned : ")) {
        const taskText = user_llmTask.replace(/Task assigned\s*:\s*/, "")
        console.log("LLM found potential task from conversations:", taskText)

        const isDuplicateLlmTask = await isDuplicateTask(taskText, 'conversations')
        if (!isDuplicateLlmTask) {
          await storeDetectedTask(taskText, "unknown", 'conversations', "Meeting")
        } else {
          console.log("Duplicate task detected from conversations, skipping addition")
        }
      } else {
        console.log("No task found in conversations")
      }
    }

    let removeListener: (() => void) | undefined

    if (privacyChoice === 'agree') {
      removeListener = Highlight.app.addListener('onConversationSaved', onConversationSaved)
    }

    return () => {
      if (removeListener) {
        removeListener()
      }
    }
  }, [isInitialized, privacyChoice])

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const text = e.target.value;
    setInputText(text);
    setSearchQuery(text); // Update search query as user types
  };

  const handleNewTaskSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (inputText.trim()) {
      await addTask({
        id: uuidv4(),
        metadata: { status: 'pending', additionMethod: 'manually', source: 'Manual Entry', assignedBy: nameRef.current },
        text: inputText
      });
      await Highlight.reporting.trackEvent('Task Added Manually')
      setInputText(""); // Clear input after adding task
      setSearchQuery(""); // Clear search query
    }
  };

  const updateTodo = async (id: string, text: string) => {
    const todo = todos.find(todo => todo.id === id);
    await Highlight.vectorDB.updateText(tasksTableName, id, text,
      { status: todo?.status,
        additionMethod: todo?.additionMethod,
        lastModified: new Date().toISOString() });
    loadTasks();
  }

  const toggleTodo = async (id: string) => {
    const todo = todos.find(todo => todo.id === id)
    const newStatus = todo?.status === 'completed' ? 'pending' : 'completed'

    // Clear summaries regardless of the new status
    await clearSummaries()

    await Highlight.vectorDB.updateMetadata(tasksTableName, id, {
      ...todo,
      status: newStatus,
      lastModified: new Date().toISOString(),
    })

    loadTasks()
  }

  const toggleTodoWithFadeOut = async (id: string) => {
    // Find the todo item and update its 'fadingOut' state temporarily
    const updatedTodos = todos.map(todo => {
      if (todo.id === id) {
        return { ...todo, fadingOut: true }; // Add a fadingOut property
      }
      return todo;
    });
    setTodos(updatedTodos);
    setTimeout(async () => {
      toggleTodo(id);
    }, 1000); // Delay of 1 second for the fade-out effect
  };

  const deleteTodo = async (id: string) => {
    const todo = todos.find(todo => todo.id === id);
    const additionMethod = todo?.additionMethod;
    if (additionMethod === 'automatically') {
      // For automatically added tasks, update the status to 'deleted' instead of deleting, so that we don't add it again
      await Highlight.vectorDB.updateMetadata(tasksTableName, id,
        { status: 'deleted',
          additionMethod: additionMethod,
          lastModified: new Date().toISOString(),
          sourceId: todo?.sourceId });
    } else {
      await Highlight.vectorDB.deleteItem(tasksTableName, id);
    }
    loadTasks();
  };

  const toggleHelp = async () => {
    await Highlight.appStorage.set("showHelpSection", !showHelpSection);
    setShowHelpSection(!showHelpSection);
  }

  // Function to add tag to a todo
  const addTagToTodo = async (todoId: string, tag: string) => {
    const todo = todos.find(t => t.id === todoId);
    if (todo) {
      const newTags = [...(todo.tags || [])];
      if (!newTags.includes(tag.toLowerCase())) {
        newTags.push(tag.toLowerCase());
        await Highlight.vectorDB.updateMetadata(tasksTableName, todoId, {
          ...todo,
          tags: newTags,
          lastModified: new Date().toISOString()
        });
        loadTasks();

        // Update allTags
        setAllTags(prev => new Set([...Array.from(prev), tag.toLowerCase()]));
      }
    }
  };

  // Add function to remove tag from a todo
  const removeTagFromTodo = async (todoId: string, tagToRemove: string) => {
    const todo = todos.find(t => t.id === todoId);
    if (todo) {
      const newTags = todo.tags.filter(tag => tag !== tagToRemove);
      await Highlight.vectorDB.updateMetadata(tasksTableName, todoId, {
        ...todo,
        tags: newTags,
        lastModified: new Date().toISOString()
      });

      // Check if this tag is used by any other todos
      const isTagUsedElsewhere = todos.some(t =>
        t.id !== todoId && t.tags && t.tags.includes(tagToRemove)
      );

      // If tag is not used elsewhere, remove it from allTags
      if (!isTagUsedElsewhere) {
        const updatedTags = new Set(allTags);
        updatedTags.delete(tagToRemove);
        setAllTags(updatedTags);

        // If the removed tag was active, switch to 'all'
        if (activeTag === tagToRemove) {
          setActiveTag('all');
        }
      }

      loadTasks();
    }
  };

  // Filter todos based on active tag and search
  const filteredTodos = todos
    .filter(todo => {
      const matchesTag = activeTag === "all" || (todo.tags && todo.tags.includes(activeTag));
      const matchesSearch = searchQuery
        ? todo.text.toLowerCase().includes(searchQuery.toLowerCase())
        : true;
      return matchesTag && matchesSearch;
    })
    .sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());

  useEffect(() => {
    const loadSavedSummaries = async () => {
      const saved = await Highlight.appStorage.get('taskSummaries')
      if (saved) {
        setTaskSummaries(saved)
      }
    }
    loadSavedSummaries()
  }, [])

  const generateTaskSummary = async () => {
    // Clear existing summaries before generating new ones
    await clearSummaries()

    // Get today's completed tasks
    const todayStart = new Date()
    todayStart.setHours(0, 0, 0, 0)

    const completedTasks = todos.filter(todo =>
      todo.status === 'completed' &&
      new Date(todo.lastModified) >= todayStart
    )

    if (completedTasks.length === 0) return

    let summaries = []
    for (const task of completedTasks) {
      let summary = ''
      const generator = Highlight.inference.getTextPrediction(
        [{role: 'system', content: 'You are a helpful assistant that converts completed tasks into natural standup updates. Make them sound like something a developer would actually say in a standup when reporting finished work. Use past tense to indicate completion. If the task was assigned by someone else, mention that context. Keep each under 100 characters.'},
         {role: 'user', content: `Convert this completed task into a natural standup update: "${task.text}"`}],
        {temperature: 0.7}
      )

      for await (const part of generator) {
        summary += part
      }

      summaries.push({
        taskId: task.id,
        summary: summary.replace(/^[-•*]\s*/, '').trim(),
        timestamp: new Date().toISOString()
      })
    }

    setTaskSummaries(summaries)
    await Highlight.appStorage.set('taskSummaries', summaries)
  }

  const handleCopySummary = () => {
    const summaryText = taskSummaries
      .map(s => `• ${s.summary}`)
      .join('\n')

    navigator.clipboard.writeText(summaryText)
    setIsCopied(true)
    setTimeout(() => setIsCopied(false), 2000)
  }

  const clearSummaries = async () => {
    setTaskSummaries([])
    await Highlight.appStorage.set('taskSummaries', [])
  }

  // Add this helper function inside Todo component
  const removeSummaryForTask = async (taskId: string) => {
    const newSummaries = taskSummaries.filter(summary => summary.taskId !== taskId)
    setTaskSummaries(newSummaries)
    await Highlight.appStorage.set('taskSummaries', newSummaries)
  }

  const handleUpdateDueDate = async (id: string, date: string | undefined) => {
    const todo = todos.find(t => t.id === id)
    if (todo) {
      await Highlight.vectorDB.updateMetadata(tasksTableName, id, {
        ...todo,
        dueDate: date,
        lastModified: new Date().toISOString()
      })
      loadTasks()
    }
  }

  const handleAddReminder = (taskId: string) => {
    setSelectedTaskId(taskId)
    setShowReminderModal(true)
  }

  useEffect(() => {
    if (!isInitialized) return;

    // Set up periodic refresh of detected tasks
    const refreshInterval = setInterval(() => {
      loadDetectedTasks();
    }, 5000); // Refresh every 5 seconds

    return () => {
      clearInterval(refreshInterval);
    };
  }, [isInitialized]);

  if (!isInitialized) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 p-8 flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-700 dark:text-gray-300">
            Initializing...
          </h2>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 p-8">
      <div className="max-w-6xl mx-auto flex gap-6">
        <Card className={cn(
          "bg-white/80 dark:bg-gray-900/80 backdrop-blur-lg shadow-xl rounded-2xl overflow-hidden border-0 dark:ring-1 dark:ring-white/10",
          detectedTasks.length === 0 && pendingReminders.length === 0 ? "w-full" : "flex-1"
        )}>
          {/* Header Section */}
          <div className="bg-white dark:bg-gray-900 border-b dark:border-gray-800 p-4">
            <div className="flex items-center justify-between mb-2"> {/* Reduced margin */}
              <div className="flex flex-col"> {/* Changed to flex-col for better alignment */}
                <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent">
                  Tasks
                </h1>
                {isEditingName ? (
                  <input
                    type="text"
                    value={name}
                    onChange={(e) => handleNameUpdate(e.target.value)}
                    onBlur={() => setIsEditingName(false)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') setIsEditingName(false);
                    }}
                    className="mt-1 px-0 text-sm text-gray-600 dark:text-gray-400 bg-transparent border-b border-gray-300 dark:border-gray-700 focus:outline-none focus:border-blue-500 dark:focus:border-blue-400"
                    autoFocus
                  />
                ) : (
                  <button
                    onClick={() => setIsEditingName(true)}
                    className="mt-1 text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 transition-colors"
                  >
                    {name}&apos;s workspace
                  </button>
                )}
              </div>
              <div className="flex items-center gap-2">
                {privacyChoice === 'disagree' && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleSettingsClick}
                    className="text-blue-600 dark:text-blue-400 hover:bg-blue-50 dark:hover:bg-blue-900/50"
                  >
                    <Settings className="w-4 h-4 mr-2" />
                    Enable Automatic Tasks
                  </Button>
                )}
                <Button
                  variant="ghost"
                  size="icon"
                  className="rounded-full"
                  onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
                >
                  <Sun className="h-5 w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
                  <Moon className="absolute h-5 w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
                  <span className="sr-only">Toggle theme</span>
                </Button>
              </div>
            </div>

            {/* Search/Add Task form */}
            <form onSubmit={handleNewTaskSubmit} className="flex items-center gap-4 mt-3"> {/* Reduced margin */}
              <div className="flex-1 relative">
                <Search className="w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2" />
                <Input
                  type="text"
                  placeholder="Add a new task or search..."
                  value={inputText}
                  onChange={handleInputChange}
                  className="w-full pl-10 dark:bg-gray-800 dark:border-gray-700"
                />
              </div>
              <Button
                type="submit"
                className="bg-gradient-to-r from-blue-600 to-purple-600 hover:opacity-90 text-white"
              >
                <Plus className="w-4 h-4 mr-2" />
                Add Task
              </Button>
            </form>
          </div>

          {/* Main Content */}
          <CardContent className="p-4"> {/* Reduced padding */}
            {/* Tags filter */}
            {allTags.size > 0 && (
              <div className="flex gap-2 mb-2 overflow-x-auto"> {/* Reduced margin */}
                <Button
                  variant={activeTag === "all" ? "default" : "ghost"}
                  className={`rounded-full px-4 ${
                    activeTag === "all"
                      ? "bg-blue-600 dark:bg-blue-600 text-white hover:bg-blue-700 dark:hover:bg-blue-700"
                      : "hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-300 dark:hover:text-gray-200"
                  }`}
                  onClick={() => setActiveTag("all")}
                >
                  All Tasks
                </Button>
                {Array.from(allTags).map((tag) => (
                  <Button
                    key={tag}
                    variant={activeTag === tag ? "default" : "ghost"}
                    className={`rounded-full px-4 ${
                      activeTag === tag
                        ? "bg-blue-600 dark:bg-blue-600 text-white hover:bg-blue-700 dark:hover:bg-blue-700"
                        : "hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-300 dark:hover:text-gray-200"
                    }`}
                    onClick={() => setActiveTag(tag)}
                  >
                    #{tag}
                  </Button>
                ))}
              </div>
            )}

            {/* Tasks list */}
            <div className="space-y-3 rounded-lg mt-4">
              {filteredTodos.filter(todo => todo.status === 'pending').length === 0 ? (
                <div className="bg-white/50 dark:bg-gray-800/50 rounded-lg p-8 min-h-[120px] flex items-center justify-center">
                  <div className="text-gray-500 dark:text-gray-400 text-center">
                    <p className="font-medium">No tasks yet</p>
                    <p className="text-sm mt-1">Add a new task using the input above</p>
                  </div>
                </div>
              ) : (
                <div className="space-y-3">
                  {filteredTodos
                    .filter(todo => todo.status === 'pending')
                    .map((todo) => (
                      <TodoItem
                        key={todo.id}
                        todo={todo}
                        onCheckedChange={toggleTodo}
                        onDelete={deleteTodo}
                        onUpdate={updateTodo}
                        onAddTag={addTagToTodo}
                        onRemoveTag={removeTagFromTodo}
                        onUpdateDueDate={handleUpdateDueDate}
                        allTags={allTags}
                        isCalendarOpen={openCalendarId === todo.id}
                        onCalendarOpenChange={(isOpen) => setOpenCalendarId(isOpen ? todo.id : null)}
                        onAddReminder={handleAddReminder}
                      />
                    ))}
                </div>
              )}
            </div>

            {/* Completed Tasks Section */}
            <Collapsible
              open={showCompletedTodos}
              onOpenChange={setShowCompletedTodos}
              className="mt-4"
            >
              <CollapsibleTrigger
                className="flex items-center justify-between w-full p-2 hover:bg-gray-50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200 dark:text-gray-300"
              >
                <span className="flex items-center gap-2">
                  <ChevronDown
                    className={`w-4 h-4 transition-transform ${
                      showCompletedTodos ? 'rotate-180' : ''
                    }`}
                  />
                  {showCompletedTodos ? 'Hide' : 'Show'} Completed Tasks
                </span>
              </CollapsibleTrigger>
              <CollapsibleContent className="space-y-2 mt-2">
                {filteredTodos
                  .filter(todo => todo.status === 'completed')
                  .map((todo) => (
                    <TodoItem
                      key={todo.id}
                      todo={todo}
                      onCheckedChange={toggleTodo}
                      onDelete={deleteTodo}
                      onUpdate={updateTodo}
                      onAddTag={addTagToTodo}
                      onRemoveTag={removeTagFromTodo}
                      onUpdateDueDate={handleUpdateDueDate}
                      allTags={allTags}
                      isCalendarOpen={openCalendarId === todo.id}
                      onCalendarOpenChange={(isOpen) => setOpenCalendarId(isOpen ? todo.id : null)}
                      onAddReminder={handleAddReminder}
                    />
                  ))}
              </CollapsibleContent>
            </Collapsible>

            {todos.some(todo =>
              todo.status === 'completed' &&
              new Date(todo.lastModified) >= new Date(new Date().setHours(0,0,0,0))
            ) && (
              <Card className="mt-6 bg-white/90 dark:bg-gray-900/90 backdrop-blur-lg shadow-md border-0 dark:ring-1 dark:ring-white/10">
                <div className="p-4 border-b dark:border-gray-800">
                  <div className="flex items-center justify-between">
                    <div className="space-y-1">
                      <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-100">
                        Daily Summary
                      </h2>
                      <p className="text-sm text-gray-500 dark:text-gray-400">
                        Generate a summary of today&apos;s completed tasks
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        onClick={generateTaskSummary}
                        className="bg-gradient-to-r from-blue-600 to-purple-600 hover:opacity-90 text-white"
                      >
                        Generate Summary
                      </Button>
                      {taskSummaries.length > 0 && (
                        <>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                            onClick={handleCopySummary}
                          >
                            <Copy className="w-4 h-4 mr-2" />
                            {isCopied ? 'Copied!' : 'Copy'}
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                            onClick={clearSummaries}
                          >
                            <Trash2 className="w-4 h-4 mr-2" />
                            Clear
                          </Button>
                        </>
                      )}
                    </div>
                  </div>
                </div>
                <CardContent className="p-4">
                  {taskSummaries.length > 0 ? (
                    <div className="space-y-3 mt-2">
                      {taskSummaries.map((summary) => (
                        <div
                          key={summary.taskId}
                          className="flex items-start gap-3 text-sm text-gray-700 dark:text-gray-200 bg-white/50 dark:bg-gray-800/50 rounded-lg p-4 border border-gray-100 dark:border-gray-700/50"
                        >
                          <span className="flex-shrink-0 mt-1.5 w-2 h-2 rounded-full bg-blue-500"></span>
                          <span className="flex-1 leading-relaxed">{summary.summary}</span>
                        </div>
                      ))}
                      {/* Update notification styling */}
                      {todos.filter(t =>
                        t.status === 'completed' &&
                        new Date(t.lastModified) >= new Date(new Date().setHours(0,0,0,0)) &&
                        !taskSummaries.some(s => s.taskId === t.id)
                      ).length > 0 && (
                        <div className="mt-4 text-sm text-blue-600 dark:text-blue-400 bg-blue-50/80 dark:bg-blue-900/30 border border-blue-100 dark:border-blue-800/50 rounded-lg p-3.5 flex items-center gap-2">
                          <AlertCircle className="w-4 h-4" />
                          <span>
                            {todos.filter(t =>
                              t.status === 'completed' &&
                              new Date(t.lastModified) >= new Date(new Date().setHours(0,0,0,0)) &&
                              !taskSummaries.some(s => s.taskId === t.id)
                            ).length} new tasks completed. Click &quot;Generate Summary&quot; to update.
                          </span>
                        </div>
                      )}
                    </div>
                  ) : (
                    <div className="text-sm text-blue-600 dark:text-blue-400 bg-blue-50/80 dark:bg-blue-900/30 border border-blue-100 dark:border-blue-800/50 rounded-lg p-4 my-2 flex items-center gap-2">
                      <AlertCircle className="w-4 h-4 flex-shrink-0" />
                      <span>
                        {todos.filter(t =>
                          t.status === 'completed' &&
                          new Date(t.lastModified) >= new Date(new Date().setHours(0,0,0,0))
                        ).length} tasks completed today. Click &quot;Generate Summary&quot; to create an update.
                      </span>
                    </div>
                  )}
                </CardContent>
              </Card>
            )}
          </CardContent>
        </Card>

        {(detectedTasks.length > 0 || pendingReminders.length > 0) && (
          <div className="w-80 space-y-6">
            <DetectedTasksCard
              tasks={detectedTasks}
              onAccept={handleAcceptTask}
              onDecline={handleDeclineTask}
            />
            <RemindersView />
          </div>
        )}
      </div>

      {showReminderModal && selectedTaskId && (
        <ReminderModal
          taskId={selectedTaskId}
          dueDate={todos.find(t => t.id === selectedTaskId)?.dueDate}
          onClose={() => {
            setShowReminderModal(false)
            setSelectedTaskId(null)
          }}
        />
      )}
    </div>
  );
}
