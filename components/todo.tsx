/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/cthBC3Tlnxc
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client"

import { useEffect, useState, useRef } from "react";
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import Highlight, { type HighlightContext, type FocusedWindow } from "@highlight-ai/app-runtime";
import { useName } from './providers/NameProvider'; // Adjust the path based on where you save the context

export interface Task {
  id: string;
  text: string;
  completed: boolean;
}

export function Todo() {
  const lastCallTime = useRef(0);
  const [todos, setTodos] = useState<Task[]>([]);
  const [newTodo, setNewTodo] = useState("")
  const { name, handleNameUpdate } = useName(); // Destructure name and handleNameUpdate from the context
  const [ userName, setUserName] = useState(name);
  const nameRef = useRef(name); // Ref to hold the current name

  const [isEditingName, setIsEditingName] = useState(false)

  useEffect(() => {
    nameRef.current = name;
  }, [name]);

  const handleUserNameEdit = () => {
    setIsEditingName(true)
  }
  const handleUserNameSave = (newName: string) => {
    handleNameUpdate(newName)
    setIsEditingName(false)
  }

  const tableName = "tasks";

  // Load tasks from the VectorDB
  const loadTasks = async () => {
    const tasks = await Highlight.vectorDB.getAllItems(tableName);
    // tasks is just a string array, convert it to Task[]
    const taskObjects = tasks.map((task, index: number) => {
      return { id: task.id, text: task.text, completed: task.metadata.completed || false };
    });
    setTodos(taskObjects);
  };

  const addTask = async (task: string) => {
    console.log("Adding task : ", task);
    await Highlight.vectorDB.insertItem(tableName, task, { completed: false });
    await Highlight.app.showNotification('New task added to TODO list', task);
    loadTasks();
  }

  useEffect(() => {
    const destructor = Highlight.app.addListener('onContext', async (context: HighlightContext) => {
      if (context.suggestion) {
        addTask(context.suggestion);
      }
    })

    return () => {
      destructor();
    };
  }, []);

  const detectTask = async (context: HighlightContext) => {
    console.log("Context", context);
    const system_prompt = `The user will provide his/her full name followed by the OCR content of their Slack window. Looking at the slack conversations, detect if there is any task that the user has to complete that needs to be added to his/her TODO list. If there is no task detected for the current user, just output "No task", without any other explanations. If a task is detected, start your reply with the prefix "Task detected :" followed by a short single line item that can added to my TODO list. No other explanation is needed.`;
    const user_prompt = "My name is " + nameRef.current +  ".\nHere is my OCR : " + context.environment.ocrScreenContents;
    const grammar = `
      root ::= ("No task" | "Task detected : " single-line)
      single-line ::= [^\n.]+ ("." | "\n")
      `;

    const response = await Highlight.inference.requestCompletionSlm(system_prompt, user_prompt, grammar)
    return response;
  }

  const isDuplicateTask = async (task: string) => {
    const closestTask = await Highlight.vectorDB.search(tableName, task, 1);
    if (closestTask.length === 0) {
      console.log("No closest task found");
      return false;
    }
    console.log("Closest task", closestTask);
    if (Math.abs(closestTask[0].distance) < 0.25) {
      console.log("Duplicate task detected");
      return true
    }
    console.log("New task detected");
    return false;
  }

  useEffect(() => {
    const onPeriodicForegroundAppCheck = async (context: FocusedWindow) => {
      console.log(context);
      // Check if it is slack
      if (context.url?.includes("app.slack.com") || context.appName === "Slack") {
        const now = Date.now();
        if (now - lastCallTime.current >= 30000) { // 30 seconds
          lastCallTime.current = now;
          console.log("Slack is open");
          const context = await Highlight.user.getContext(true)
          const task = await detectTask(context);
          console.log(task);
          if (task.startsWith("Task detected : ")) {
            // Extract the task
            const taskText = task.replace("Task detected : ", "");

            if (await isDuplicateTask(taskText)) {
              return;
            }
            await addTask(taskText);
          }

        } else {
          // console.log("Throttled: Context fetch not allowed yet");
        }
      }
    };

    //let removeListener = Highlight.app.addListener("onContext", onContext);
    let removeListener = Highlight.app.addListener("onPeriodicForegroundAppCheck", onPeriodicForegroundAppCheck);

    return () => {
      removeListener();
    };
  }, []);

  useEffect(() => {
    loadTasks();
  }, []);

  const addTodo = async () => {
    if (newTodo.trim() === "") {
      return;
    }
    if (await isDuplicateTask(newTodo)) {
      return;
    }
    await Highlight.vectorDB.insertItem(tableName, newTodo, { completed: false });
    setNewTodo("");
    loadTasks();
  }
  const toggleTodo = async (id: string) => {
    await Highlight.vectorDB.updateMetadata(tableName, id, { completed: !todos.find(todo => todo.id === id)?.completed });
    loadTasks();
  };

  const deleteTodo = async (id: string) => {
    await Highlight.vectorDB.deleteItem(tableName, id);
    loadTasks();
  };
  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <div className="w-full max-w-4xl p-6 bg-card rounded-lg shadow-md relative">
        <div className="absolute top-4 right-4 flex items-center space-x-2">
          {isEditingName ? (
            <div className="flex items-center">
              <Input
                type="text"
                value={userName}
                onChange={(e) => setUserName(e.target.value)}
                className="bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              />
              <Button
                onClick={() => handleUserNameSave(userName)}
                className="bg-primary text-primary-foreground rounded-md px-3 py-2 ml-2"
              >
                Save
              </Button>
            </div>
          ) : (
            <div className="cursor-pointer hover:underline" onClick={handleUserNameEdit}>
              {name}
            </div>
          )}
        </div>
        <h1 className="text-2xl font-bold mb-4 text-card-foreground">Todo List - alpha version</h1>
        <div className="flex items-center mb-4">
          <Input
            type="text"
            placeholder="Add a new todo"
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                addTodo()
              }
            }}
            className="flex-1 mr-2 bg-input text-input-foreground rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
          />
          <Button onClick={addTodo} className="bg-primary text-primary-foreground rounded-md px-3 py-2">
            Add
          </Button>
        </div>
        <div className="space-y-2">
          {todos.map((todo) => (
            <div
              key={todo.id}
              className={`flex items-center justify-between bg-muted rounded-md px-3 py-2 ${
                todo.completed ? "line-through text-muted-foreground" : "text-card-foreground"
              }`}
            >
              <div className="flex items-center">
                <Checkbox
                  id={`todo-${todo.id}`}
                  checked={todo.completed}
                  className="mr-2"
                  onCheckedChange={() => toggleTodo(todo.id)}
                />
                <label htmlFor={`todo-${todo.id}`}>{todo.text}</label>
              </div>
              <Button
                variant="ghost"
                size="icon"
                onClick={() => deleteTodo(todo.id)}
                className="text-muted-foreground hover:text-card-foreground"
              >
                <Trash2Icon className="w-4 h-4" />
              </Button>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

function Trash2Icon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 6h18" />
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
      <line x1="10" x2="10" y1="11" y2="17" />
      <line x1="14" x2="14" y1="11" y2="17" />
    </svg>
  )
}
