/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/cthBC3Tlnxc
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client"

import { useEffect, useState, useRef, useMemo } from "react";
import { Card, CardContent } from '@/components/ui/card';
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { 
  Plus, 
  Search, 
  Tag, 
  Trash2, 
  AlertCircle,
  ChevronDown,
  MoreVertical,
  CheckCircle2,
  Circle,
  UserIcon,
  Moon,
  Sun,
  X
} from 'lucide-react';
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from "@/components/ui/collapsible"
import Highlight, { type HighlightContext, type FocusedWindow } from "@highlight-ai/app-runtime";
import { useName } from './providers/NameProvider'; // Adjust the path based on where you save the context
import { v4 as uuidv4 } from 'uuid';
import { tasks_system_prompt, conversations_system_prompt } from './prompts';
import { useTheme } from "next-themes"

type StatusType = 'pending' | 'completed' | 'deleted' | 'false_positive';
type AdditionMethodType = 'manually' | 'automatically' | 'semi_automatically';

export interface Task {
  id: string;
  text: string;
  status: StatusType;
  additionMethod: AdditionMethodType;
  fadingOut: boolean;
  lastModified: string;
  priority: 'high' | 'medium' | 'low';
  sourceId: string;
  tags: string[];  // Changed from single category to multiple tags
}

interface TodoItemProps {
  todo: Task;
  onCheckedChange: (id: string) => void;
  onDelete: (id: string) => void;
  onUpdate: (id: string, text: string) => void;
  onAddTag: (todoId: string, tag: string) => void;
  onRemoveTag: (todoId: string, tag: string) => void; // Add this
  allTags: Set<string>;
}

const TodoItem: React.FC<TodoItemProps> = ({ todo, onCheckedChange, onDelete, onUpdate, onAddTag, onRemoveTag, allTags }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  const [isAddingTag, setIsAddingTag] = useState(false);
  const [newTag, setNewTag] = useState("");
  const [filteredTags, setFilteredTags] = useState<string[]>([]);
  const tagInputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const tagPopupRef = useRef<HTMLDivElement>(null);
  const todoItemRef = useRef<HTMLDivElement>(null);
  const [showAbove, setShowAbove] = useState(false);

  const priorityColors = {
    high: 'bg-red-50 border-red-200 hover:bg-red-100',
    medium: 'bg-yellow-50 border-yellow-200 hover:bg-yellow-100',
    low: 'bg-green-50 border-green-200 hover:bg-green-100'
  };

  const categoryColors = {
    Development: 'text-purple-600 bg-purple-100',
    Bugs: 'text-red-600 bg-red-100',
    Feature: 'text-blue-600 bg-blue-100',
    Design: 'text-green-600 bg-green-100'
  };

  // Get existing tags once
  const existingTags = useMemo(() => 
    Array.from(allTags).filter(tag => !todo.tags?.includes(tag)),
    [allTags, todo.tags]
  );

  // Update filtered tags when search changes
  useEffect(() => {
    if (newTag.trim()) {
      const filtered = existingTags.filter(tag => 
        tag.toLowerCase().includes(newTag.toLowerCase())
      );
      setFilteredTags(filtered);
    } else {
      setFilteredTags(existingTags);
    }
  }, [newTag, existingTags]); // Only depend on newTag and existingTags

  // Update edit text when todo changes
  useEffect(() => {
    setEditText(todo.text);
  }, [todo.text]);

  // Handle popup position
  useEffect(() => {
    const updatePopupPosition = () => {
      if (todoItemRef.current && tagPopupRef.current) {
        const todoRect = todoItemRef.current.getBoundingClientRect();
        const popupHeight = tagPopupRef.current.offsetHeight;
        const viewportHeight = window.innerHeight;
        const spaceBelow = viewportHeight - todoRect.bottom;
        setShowAbove(spaceBelow < (popupHeight + 10));
      }
    };

    if (isAddingTag) {
      updatePopupPosition();
      window.addEventListener('scroll', updatePopupPosition, true);
      window.addEventListener('resize', updatePopupPosition);
    }

    return () => {
      window.removeEventListener('scroll', updatePopupPosition, true);
      window.removeEventListener('resize', updatePopupPosition);
    };
  }, [isAddingTag]); // Only depend on isAddingTag

  // Handle click outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (isAddingTag && 
          tagPopupRef.current && 
          !tagPopupRef.current.contains(e.target as Node)) {
        setIsAddingTag(false);
        setNewTag("");
      }
    };

    if (isAddingTag) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isAddingTag]); // Only depend on isAddingTag

  // Focus tag input when adding
  useEffect(() => {
    if (isAddingTag && tagInputRef.current) {
      tagInputRef.current.focus();
    }
  }, [isAddingTag]); // Only depend on isAddingTag

  const handleTagSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTag.trim()) {
      onAddTag(todo.id, newTag.trim());
      setNewTag("");
      setIsAddingTag(false);
    }
  };

  const handleTagSelect = (tag: string) => {
    onAddTag(todo.id, tag);
    setNewTag("");
    setIsAddingTag(false);
  };

  const handleTagKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Escape') {
      setIsAddingTag(false);
      setNewTag("");
    } else if (e.key === 'ArrowDown' && filteredTags.length > 0) {
      e.preventDefault();
      const firstTag = dropdownRef.current?.querySelector('button');
      firstTag?.focus();
    }
  };

  const handleClick = () => setIsEditing(true);
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setEditText(e.target.value);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === 'Escape') {
      if (e.key === 'Enter') {
        onUpdate(todo.id, editText);
      }
      setIsEditing(false);
      setEditText(todo.text);
    }
  };

  const handleBlur = () => {
    onUpdate(todo.id, editText);
    setIsEditing(false);
  };

  return (
    <div 
      ref={todoItemRef}
      className="group relative rounded-xl border dark:border-gray-700 p-3 transition-all duration-200 hover:shadow-md dark:bg-gray-800/50 dark:hover:bg-gray-800/80"
    >
      <div className="flex items-start gap-3">
        <button 
          onClick={() => onCheckedChange(todo.id)} 
          className="flex-shrink-0 mt-1 focus:outline-none"
        >
          {todo.status === 'completed' ? (
            <CheckCircle2 className="w-5 h-5 text-blue-500 dark:text-blue-400" />
          ) : (
            <Circle className="w-5 h-5 text-gray-400 group-hover:text-blue-500 dark:group-hover:text-blue-400 transition-colors" />
          )}
        </button>
        
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            {isEditing ? (
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                onKeyDown={handleKeyDown}
                onBlur={handleBlur}
                className="flex-grow px-2 py-1 text-sm rounded-md border dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
                autoFocus
              />
            ) : (
              <span 
                className={`text-base font-medium truncate cursor-pointer ${
                  todo.status === 'completed' 
                    ? 'line-through text-gray-400 dark:text-gray-500' 
                    : 'text-gray-900 dark:text-gray-100'
                }`} 
                onClick={() => setIsEditing(true)}
              >
                {todo.text}
              </span>
            )}
          </div>

          {/* Updated Tags display with better spacing */}
          {todo.tags && todo.tags.length > 0 && (
            <div className="flex flex-wrap gap-1 mt-1">
              {todo.tags.map((tag) => (
                <span
                  key={tag}
                  className="inline-flex items-center text-xs font-medium rounded-full bg-blue-100/80 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300 group/tag"
                >
                  <span className="px-2 py-0.5">#{tag}</span>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onRemoveTag(todo.id, tag);
                    }}
                    className="w-0 group-hover/tag:w-4 overflow-hidden transition-all duration-200 hover:bg-blue-200 dark:hover:bg-blue-800 rounded-r-full"
                  >
                    <X className="w-3 h-3 mx-0.5" />
                  </button>
                </span>
              ))}
            </div>
          )}
        </div>

        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
          <Button
            variant="ghost"
            size="sm"
            className="text-gray-500 hover:text-gray-700 p-1"
            onClick={() => setIsAddingTag(true)}
          >
            <Tag className="w-4 h-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            className="text-gray-500 hover:text-red-600 p-1"
            onClick={() => onDelete(todo.id)}
          >
            <Trash2 className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* Tag Popup */}
      {isAddingTag && (
        <div 
          ref={tagPopupRef}
          className={`absolute ${
            showAbove 
              ? 'bottom-full mb-2' 
              : 'top-full mt-2'
          } right-0 z-10 bg-white dark:bg-gray-800 rounded-lg shadow-lg dark:shadow-gray-900/50`}
        >
          <div className="p-2">
            <form onSubmit={handleTagSubmit} className="flex items-center gap-2">
              <Input
                ref={tagInputRef}
                type="text"
                placeholder="Add tag..."
                value={newTag}
                onChange={(e) => setNewTag(e.target.value)}
                onKeyDown={handleTagKeyDown}
                className="text-sm w-48 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:placeholder-gray-400"
                autoFocus
              />
              <Button 
                type="submit" 
                size="sm" 
                variant="ghost" 
                className="text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300"
              >
                Add
              </Button>
            </form>
          </div>

          {/* Existing Tags Dropdown */}
          {filteredTags.length > 0 && (
            <div 
              ref={dropdownRef}
              className="border-t dark:border-gray-700 overflow-y-auto p-1"
            >
              {filteredTags.map((tag) => (
                <button
                  key={tag}
                  onClick={() => handleTagSelect(tag)}
                  className="w-full text-left px-3 py-1.5 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-700/50 rounded-md focus:bg-gray-100 dark:focus:bg-gray-700/50 focus:outline-none flex items-center gap-2"
                >
                  <Tag className="w-3 h-3" />
                  <span>{tag}</span>
                </button>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export function Todo() {
  const lastAppsCheckTime = useRef(0);
  const lastConversationsCheckTime = useRef(0);
  const [todos, setTodos] = useState<Task[]>([]);
  const [newTodo, setNewTodo] = useState("")
  const { name, handleNameUpdate } = useName(); // Destructure name and handleNameUpdate from the context
  const [ userName, setUserName] = useState(name);
  const nameRef = useRef(name); // Ref to hold the current name
  const [searchQuery, setSearchQuery] = useState("");
  const [inputText, setInputText] = useState("");

  const [isEditingName, setIsEditingName] = useState(false)
  const [showCompletedTodos, setShowCompletedTodos] = useState(false)
  const [showHelpSection, setShowHelpSection] = useState(false)
  const [hotKey, setHotKey] = useState("")
  const [slmCapable, setSlmCapable] = useState(false);
  const [newTaskText, setNewTaskText] = useState("");

  const tasksTableName = "tasks";
  const sourcesTableName = "sources";

  const [allTags, setAllTags] = useState<Set<string>>(new Set());
  const [activeTag, setActiveTag] = useState<string>("all");
  const [isAddingTag, setIsAddingTag] = useState<{todoId: string; isOpen: boolean}>({ todoId: '', isOpen: false });
  const { theme, setTheme } = useTheme()
  
  useEffect(() => {
    nameRef.current = name;
  }, [name]);

  useEffect(() => {
    Highlight.permissions.requestBackgroundPermission();
  }, []);

  useEffect(() => {
    const getShowHelpSection = async () => {
      const showHelp = await Highlight.appStorage.get("showHelpSection") ?? true;
      setShowHelpSection(showHelp);
    }
    getShowHelpSection();
  }, []);

  useEffect(() => {
    const isSlmCapable = async () => {
      setSlmCapable(await Highlight.inference.isSlmCapable());
    }
    isSlmCapable();
  }, []);

  useEffect(() => {
    const getHotKey = async () => {
      const hotKey = await Highlight.app.getHotkey();
      setHotKey(hotKey);
    }
    getHotKey();
  }, []);

  const handleUserNameEdit = () => {
    setIsEditingName(true)
  }
  const handleUserNameSave = (newName: string) => {
    handleNameUpdate(newName)
    setIsEditingName(false)
  }

  // Load tasks from the VectorDB
  const loadTasks = async () => {
    try {
      const tasks = await Highlight.vectorDB.getAllItems(tasksTableName);
      const taskObjects = tasks.map((task) => ({
        id: task.id,
        text: task.text,
        status: task.metadata.status,
        additionMethod: task.metadata.additionMethod,
        lastModified: task.metadata.lastModified,
        fadingOut: false,
        priority: task.metadata.priority,
        sourceId: task.metadata.sourceId,
        tags: task.metadata.tags || [] // Ensure tags is always an array
      }));
      
      // Collect all unique tags from tasks
      const tagsSet = new Set<string>();
      taskObjects.forEach(task => {
        if (task.tags) {
          task.tags.forEach((tag: string) => tagsSet.add(tag.toLowerCase()));
        }
      });
      
      setTodos(taskObjects);
      setAllTags(tagsSet); // Update allTags with collected tags
    } catch (error) {
      console.log("Error getting tasks: ", error);
    }
  };

  const isDuplicateTask = async (taskText: string, userPrompt: string): Promise<boolean> => {
    // Search for only the most similar task
    const similarTasks = await Highlight.vectorDB.search(tasksTableName, taskText, 1);

    if (similarTasks.length > 0 && Math.abs(similarTasks[0].distance) < 0.30) {
      const task = similarTasks[0];
      const metadata = JSON.parse(task.metadata);
      const existingSourceId = metadata.sourceId;

      // If task is pending, mark as duplicate immediately
      if (metadata.status === 'pending') {
        console.log("Similar task is already pending - marking as duplicate");
        return true;
      }

      if (userPrompt=='conversations') {
        return true
      }

      // Get source similarity if sourceId exists
      if (existingSourceId) {
        const existingSources = await Highlight.vectorDB.getAllItems(sourcesTableName);
        const existingSource = existingSources.find(source => source.metadata.sourceId === existingSourceId);
        const existingSourceVector = existingSource?.vector;

        let newSourceEmbedding
        try {
          newSourceEmbedding = await Highlight.inference.getEmbedding(userPrompt);
        } catch (error) {
          console.error("Error getting new source embedding: ", error);
          return false;
        }

        const similarity = cosineSimilarity(existingSourceVector, newSourceEmbedding);

        // Case 1: Task is completed/deleted and source is similar - mark as duplicate
        if ((metadata.status === 'completed' || metadata.status === 'deleted') && similarity > 0.85) {
          console.log("Task already completed with similar source - marking as duplicate");
          return true;
        }
        
        // Case 2: Task is completed/deleted but source is different - allow new task creation
        if ((metadata.status === 'completed' || metadata.status === 'deleted') && similarity <= 0.85) {
          console.log("Task was completed but has new source - allowing new task creation");
          return false;
        }
      }
    }
    return false;
  }

  const addTask = async (task: string, additionMethod: AdditionMethodType, status?: StatusType, userPrompt?: string) => {
    const sourceId = uuidv4();
    await Highlight.vectorDB.insertItem(sourcesTableName, userPrompt ?? "", {sourceId: sourceId});

    // Add new task
    await Highlight.vectorDB.insertItem(tasksTableName, task, {
      status: status || 'pending',
      additionMethod: additionMethod,
      lastModified: new Date().toISOString(),
      sourceId: sourceId
    });

    if (additionMethod === 'automatically' && status !== 'false_positive') {
      await Highlight.app.showNotification('New task added to TODO list', task);
    }
    loadTasks();
  }

  // Helper function to calculate cosine similarity
  function cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, a, i) => sum + a * vec2[i], 0);
    const magnitude1 = Math.sqrt(vec1.reduce((sum, a) => sum + a * a, 0));
    const magnitude2 = Math.sqrt(vec2.reduce((sum, a) => sum + a * a, 0));
    return dotProduct / (magnitude1 * magnitude2);
  }

  useEffect(() => {
    const destructor = Highlight.app.addListener('onContext', async (context: HighlightContext) => {
      if (context.suggestion) {
        addTask(context.suggestion, 'semi_automatically');
      }
    })

    return () => {
      destructor();
    };
  });

  const grammar = `
    root ::= ("Task not assigned" | "Task assigned : " single-line)
    single-line ::= [^\n.]+ ("." | "\n")
    `;

  useEffect(() => {
    const onPeriodicForegroundAppCheck = async (context: FocusedWindow) => {
      if (!slmCapable) return

      const now = Date.now()
      if (now - lastAppsCheckTime.current >= 15000) {
        lastAppsCheckTime.current = now

        console.log("Starting periodic apps check...")

        // Handle apps flow first
        const supportedApps = [
          // Chat/Team Apps
          "Slack",
          // "Messages",
          "app.slack.com",
          "Microsoft Teams",
          "teams.microsoft.com",
          // "Discord",
          // "discord.com",
          "Telegram",
          "telegram.org",
          "WhatsApp",
          "web.whatsapp.com",
          
          // Email Apps
          "Outlook",
          "outlook.office.com",
          "mail.google.com",
          "Superhuman",
          "Mail",
          "ProtonMail",
          "mail.proton.me",
          "Thunderbird"
        ]
        if (supportedApps.some(app => 
          context.appName === app || 
          (context.url && context.url.includes(app))
        )) {
          console.log("Processing supported app:", context.appName || context.url)
          const userContext = await Highlight.user.getContext(true)
          const screenContent = userContext.environment.ocrScreenContents ?? ""

          // Check for duplicate screen content
          const isDuplicateScreen = false // await isDuplicateTask(screenContent, screenContent)
          if (!isDuplicateScreen) {
            let user_prompt = `Name of the User: ${nameRef.current}\nConversation: ${screenContent}`
            const slmTask = await Highlight.inference.getTextPredictionSlm(
              [{role: 'system', content: tasks_system_prompt},
              {role: 'user', content: user_prompt}],
              grammar
            )

            if (slmTask.startsWith("Task assigned : ")) {
              const slmTaskText = slmTask.replace("Task assigned : ", "")
              console.log("SLM found potential task:", slmTaskText)
              
              const isDuplicateSlmTask = await isDuplicateTask(slmTaskText, user_prompt)
              if (!isDuplicateSlmTask) {
                console.log("Running LLM verification...")
                const generator = Highlight.inference.getTextPrediction(
                  [{role: 'system', content: tasks_system_prompt},
                  {role: 'user', content: user_prompt}]
                )
                
                let llmTask = ''
                for await (const part of generator) {
                  llmTask += part
                }
                
                if (llmTask.includes("Task assigned : ")) {
                  const llmTaskText = llmTask.replace(/Task assigned\s*:\s*/, "")
                  console.log("LLM verified task:", llmTaskText)
                  
                  const isDuplicateLlmTask = await isDuplicateTask(llmTaskText, user_prompt)
                  if (!isDuplicateLlmTask) {
                    await addTask(llmTaskText, 'automatically', 'pending', user_prompt)
                    console.log("Added new task from app content:", llmTaskText)
                  } else {
                    console.log("Duplicate LLM task detected from apps, skipping addition")
                  }
                } else {
                  await addTask(slmTaskText, 'automatically', 'false_positive', user_prompt)
                  console.log("Added false positive task from SLM")
                }
              } else {
                console.log("Duplicate SLM task detected from apps, skipping LLM call")
              }
            } else {
              console.log("No task found in SLM")
            }
          } else {
            console.log("Duplicate screen content detected, skipping SLM call")
          }
        }
        console.log("Periodic check for apps completed")
      }

      if (now - lastConversationsCheckTime.current >= 300000) {
        lastConversationsCheckTime.current = now

        console.log("Starting periodic conversations check...")

        // Then handle conversations flow independently
        // Log available conversations first
        const conversations = await Highlight.conversations.getAllConversations()
        // console.log("Found conversations:", conversations.length)
        if (conversations.length > 0) {
          // console.log("Recent transcripts:", conversations.slice(0, 2).map(conv => conv.transcript))
          // console.log("Processing conversations...")
          const recentTranscripts = conversations
            .slice(0, 2)
            .map(conv => conv.transcript)
            .join("\n")

          const isDuplicateInput = false //await isDuplicateTask(recentTranscripts, recentTranscripts)
          if (!isDuplicateInput) {
            const conversations_prompt = [
              `Name of the User: ${nameRef.current}`,
              `Recent Conversations: ${recentTranscripts}`
            ].join("\n")

            console.log("Running LLM for conversations...")
            const generator = Highlight.inference.getTextPrediction(
              [{role: 'system', content: conversations_system_prompt},
              {role: 'user', content: conversations_prompt}]
            )

            let llmTask = ''
            for await (const part of generator) {
              llmTask += part
            }

            if (llmTask.includes("Task assigned : ")) {
              const taskText = llmTask.replace(/Task assigned\s*:\s*/, "")
              console.log("LLM found potential task from conversations:", taskText)
              
              const isDuplicateLlmTask = await isDuplicateTask(taskText, 'conversations')
              if (!isDuplicateLlmTask) {
                await addTask(taskText, 'automatically', 'pending', 'conversations')
                console.log("Added new task from conversations:", taskText)
              } else {
                console.log("Duplicate task detected from conversations, skipping addition")
              }
            } else {
              console.log("No task found in conversations")
            }
          } else {
            console.log("Duplicate conversation detected, skipping LLM call")
          }
        }
        console.log("Periodic check for conversations completed")
      }
    };

    //let removeListener = Highlight.app.addListener("onContext", onContext);
    let removeListener = Highlight.app.addListener("onPeriodicForegroundAppCheck", onPeriodicForegroundAppCheck);

    return () => {
      removeListener();
    };
  });

  useEffect(() => {
    loadTasks();
  }, []);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const text = e.target.value;
    setInputText(text);
    setSearchQuery(text); // Update search query as user types
  };

  const handleNewTaskSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (inputText.trim()) {
      await addTask(inputText, 'manually', 'pending');
      setInputText(""); // Clear input after adding task
      setSearchQuery(""); // Clear search query
    }
  };

  const updateTodo = async (id: string, text: string) => {
    const todo = todos.find(todo => todo.id === id);
    await Highlight.vectorDB.updateText(tasksTableName, id, text,
      { status: todo?.status,
        additionMethod: todo?.additionMethod,
        lastModified: new Date().toISOString() });
    loadTasks();
  }

  const toggleTodo = async (id: string) => {
    const todo = todos.find(todo => todo.id === id);
    const newStatus = todo?.status === 'completed' ? 'pending' : 'completed';
    await Highlight.vectorDB.updateMetadata(tasksTableName, id,
      { status: newStatus,
        additionMethod: todo?.additionMethod,
        lastModified: new Date().toISOString(),
        sourceId: todo?.sourceId });
    loadTasks();
  }

  const toggleTodoWithFadeOut = async (id: string) => {
    // Find the todo item and update its 'fadingOut' state temporarily
    const updatedTodos = todos.map(todo => {
      if (todo.id === id) {
        return { ...todo, fadingOut: true }; // Add a fadingOut property
      }
      return todo;
    });
    setTodos(updatedTodos);
    setTimeout(async () => {
      toggleTodo(id);
    }, 1000); // Delay of 1 second for the fade-out effect
  };

  const deleteTodo = async (id: string) => {
    const todo = todos.find(todo => todo.id === id);
    const additionMethod = todo?.additionMethod;
    if (additionMethod === 'automatically') {
      // For automatically added tasks, update the status to 'deleted' instead of deleting, so that we don't add it again
      await Highlight.vectorDB.updateMetadata(tasksTableName, id,
        { status: 'deleted',
          additionMethod: additionMethod,
          lastModified: new Date().toISOString(),
          sourceId: todo?.sourceId });
    } else {
      await Highlight.vectorDB.deleteItem(tasksTableName, id);
    }
    loadTasks();
  };

  const toggleHelp = async () => {
    await Highlight.appStorage.set("showHelpSection", !showHelpSection);
    setShowHelpSection(!showHelpSection);
  }

  // Function to add tag to a todo
  const addTagToTodo = async (todoId: string, tag: string) => {
    const todo = todos.find(t => t.id === todoId);
    if (todo) {
      const newTags = [...(todo.tags || [])];
      if (!newTags.includes(tag.toLowerCase())) {
        newTags.push(tag.toLowerCase());
        await Highlight.vectorDB.updateMetadata(tasksTableName, todoId, {
          ...todo,
          tags: newTags,
          lastModified: new Date().toISOString()
        });
        loadTasks();
        
        // Update allTags
        setAllTags(prev => new Set([...Array.from(prev), tag.toLowerCase()]));
      }
    }
  };

  // Add function to remove tag from a todo
  const removeTagFromTodo = async (todoId: string, tagToRemove: string) => {
    const todo = todos.find(t => t.id === todoId);
    if (todo) {
      const newTags = todo.tags.filter(tag => tag !== tagToRemove);
      await Highlight.vectorDB.updateMetadata(tasksTableName, todoId, {
        ...todo,
        tags: newTags,
        lastModified: new Date().toISOString()
      });
      
      // Check if this tag is used by any other todos
      const isTagUsedElsewhere = todos.some(t => 
        t.id !== todoId && t.tags && t.tags.includes(tagToRemove)
      );
      
      // If tag is not used elsewhere, remove it from allTags
      if (!isTagUsedElsewhere) {
        const updatedTags = new Set(allTags);
        updatedTags.delete(tagToRemove);
        setAllTags(updatedTags);
        
        // If the removed tag was active, switch to 'all'
        if (activeTag === tagToRemove) {
          setActiveTag('all');
        }
      }
      
      loadTasks();
    }
  };

  // Filter todos based on active tag and search
  const filteredTodos = todos
    .filter(todo => {
      const matchesTag = activeTag === "all" || (todo.tags && todo.tags.includes(activeTag));
      const matchesSearch = searchQuery 
        ? todo.text.toLowerCase().includes(searchQuery.toLowerCase())
        : true;
      return matchesTag && matchesSearch;
    })
    .sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 p-8">
      <Card className="max-w-4xl mx-auto bg-white/80 dark:bg-gray-900/80 backdrop-blur-lg shadow-xl rounded-2xl overflow-hidden border-0 dark:ring-1 dark:ring-white/10">
        {/* Header Section */}
        <div className="bg-white dark:bg-gray-900 border-b dark:border-gray-800 p-4">
          <div className="flex items-center justify-between mb-2"> {/* Reduced margin */}
            <div className="flex flex-col"> {/* Changed to flex-col for better alignment */}
              <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 dark:from-blue-400 dark:to-purple-400 bg-clip-text text-transparent">
                Tasks
              </h1>
              {isEditingName ? (
                <input
                  type="text"
                  value={name}
                  onChange={(e) => handleNameUpdate(e.target.value)}
                  onBlur={() => setIsEditingName(false)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') setIsEditingName(false);
                  }}
                  className="mt-1 px-0 text-sm text-gray-600 dark:text-gray-400 bg-transparent border-b border-gray-300 dark:border-gray-700 focus:outline-none focus:border-blue-500 dark:focus:border-blue-400"
                  autoFocus
                />
              ) : (
                <button
                  onClick={() => setIsEditingName(true)}
                  className="mt-1 text-sm text-gray-600 dark:text-gray-400 hover:text-blue-600 dark:hover:text-blue-400 transition-colors"
                >
                  {name}&apos;s workspace
                </button>
              )}
            </div>
            <Button
              variant="ghost"
              size="icon"
              className="rounded-full"
              onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
            >
              <Sun className="h-5 w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
              <Moon className="absolute h-5 w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
              <span className="sr-only">Toggle theme</span>
            </Button>
          </div>

          {/* Search/Add Task form */}
          <form onSubmit={handleNewTaskSubmit} className="flex items-center gap-4 mt-3"> {/* Reduced margin */}
            <div className="flex-1 relative">
              <Search className="w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2" />
              <Input
                type="text"
                placeholder="Add a new task or search..."
                value={inputText}
                onChange={handleInputChange}
                className="w-full pl-10 dark:bg-gray-800 dark:border-gray-700"
              />
            </div>
            <Button 
              type="submit" 
              className="bg-gradient-to-r from-blue-600 to-purple-600 hover:opacity-90 text-white"
            >
              <Plus className="w-4 h-4 mr-2" />
              Add Task
            </Button>
          </form>
        </div>

        {/* Main Content */}
        <CardContent className="p-4"> {/* Reduced padding */}
          {/* Tags filter */}
          {allTags.size > 0 && (
            <div className="flex gap-2 mb-2 overflow-x-auto"> {/* Reduced margin */}
              <Button
                variant={activeTag === "all" ? "default" : "ghost"}
                className={`rounded-full px-4 ${
                  activeTag === "all"
                    ? "bg-blue-600 dark:bg-blue-600 text-white hover:bg-blue-700 dark:hover:bg-blue-700"
                    : "hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-300 dark:hover:text-gray-200"
                }`}
                onClick={() => setActiveTag("all")}
              >
                All Tasks
              </Button>
              {Array.from(allTags).map((tag) => (
                <Button
                  key={tag}
                  variant={activeTag === tag ? "default" : "ghost"}
                  className={`rounded-full px-4 ${
                    activeTag === tag
                      ? "bg-blue-600 dark:bg-blue-600 text-white hover:bg-blue-700 dark:hover:bg-blue-700"
                      : "hover:bg-gray-100 dark:hover:bg-gray-800 dark:text-gray-300 dark:hover:text-gray-200"
                  }`}
                  onClick={() => setActiveTag(tag)}
                >
                  #{tag}
                </Button>
              ))}
            </div>
          )}

          {/* Tasks list */}
          <div className="space-y-2 bg-white/50 dark:bg-gray-800/50 rounded-lg p-3 mt-2"> {/* Adjusted spacing */}
            {filteredTodos
              .filter(todo => todo.status === 'pending')
              .map((todo) => (
                <TodoItem
                  key={todo.id}
                  todo={todo}
                  onCheckedChange={toggleTodo}
                  onDelete={deleteTodo}
                  onUpdate={updateTodo}
                  onAddTag={addTagToTodo}
                  onRemoveTag={removeTagFromTodo} // Add this
                  allTags={allTags}
                />
              ))}
          </div>

          {/* Completed Tasks Section */}
          <Collapsible
            open={showCompletedTodos}
            onOpenChange={setShowCompletedTodos}
            className="mt-4"
          >
            <CollapsibleTrigger 
              className="flex items-center justify-between w-full p-2 hover:bg-gray-50 dark:hover:bg-gray-800/50 rounded-lg transition-colors duration-200 dark:text-gray-300"
            >
              <span className="flex items-center gap-2">
                <ChevronDown 
                  className={`w-4 h-4 transition-transform ${
                    showCompletedTodos ? 'rotate-180' : ''
                  }`} 
                />
                {showCompletedTodos ? 'Hide' : 'Show'} Completed Tasks
              </span>
            </CollapsibleTrigger>
            <CollapsibleContent className="space-y-2 mt-2">
              {filteredTodos
                .filter(todo => todo.status === 'completed')
                .map((todo) => (
                  <TodoItem
                    key={todo.id}
                    todo={todo}
                    onCheckedChange={toggleTodo}
                    onDelete={deleteTodo}
                    onUpdate={updateTodo}
                    onAddTag={addTagToTodo}
                    onRemoveTag={removeTagFromTodo} // Add this
                    allTags={allTags}
                  />
              ))}
            </CollapsibleContent>
          </Collapsible>
        </CardContent>
      </Card>
    </div>
  );
}
